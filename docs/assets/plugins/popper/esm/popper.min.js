/*
 Copyright (C) Federico Zivolo 2020
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */const e = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined'; const t = (function () {
  for (let t = ['Edge', 'Trident', 'Firefox'], o = 0; o < t.length; o += 1) {
    if (e && navigator.userAgent.indexOf(t[o]) >= 0) {
      return 1
    }
  } return 0
}()); function o(e) {
  let t = !1; return function () {
    t || (t = !0, window.Promise.resolve().then(() => {
      t = !1, e()
    }))
  }
} function n(e) {
  let o = !1; return function () {
    o || (o = !0, setTimeout(() => {
      o = !1, e()
    }, t))
  }
} const i = e && window.Promise; const r = i ? o : n; function p(e) {
  return e && {}.toString.call(e) === '[object Function]'
} function s(e, t) {
  if (e.nodeType !== 1) {
    return []
  } const o = e.ownerDocument.defaultView; const n = o.getComputedStyle(e, null); return t ? n[t] : n
} function d(e) {
  return e.nodeName === 'HTML' ? e : e.parentNode || e.host
} function a(e) {
  if (!e) {
    return document.body
  } switch (e.nodeName) {
    case 'HTML':case 'BODY':return e.ownerDocument.body; case '#document':return e.body
  } const t = s(e); const o = t.overflow; const n = t.overflowX; const i = t.overflowY; return /(auto|scroll|overlay)/.test(o + i + n) ? e : a(d(e))
} function l(e) {
  return e && e.referenceNode ? e.referenceNode : e
} const f = e && Boolean(window.MSInputMethodContext && document.documentMode); const m = e && /MSIE 10/.test(navigator.userAgent); function h(e) {
  return e === 11 ? f : e === 10 ? m : f || m
} function c(e) {
  if (!e) {
    return document.documentElement
  } for (var t = h(10) ? document.body : null, o = e.offsetParent || null; o === t && e.nextElementSibling;) {
    o = (e = e.nextElementSibling).offsetParent
  } const n = o && o.nodeName; return n && n !== 'BODY' && n !== 'HTML' ? ['TH', 'TD', 'TABLE'].indexOf(o.nodeName) !== -1 && s(o, 'position') === 'static' ? c(o) : o : e ? e.ownerDocument.documentElement : document.documentElement
} function g(e) {
  const t = e.nodeName; return t !== 'BODY' && (t === 'HTML' || c(e.firstElementChild) === e)
} function u(e) {
  return e.parentNode === null ? e : u(e.parentNode)
} function b(e, t) {
  if (!e || !e.nodeType || !t || !t.nodeType) {
    return document.documentElement
  } const o = e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_FOLLOWING; const n = o ? e : t; const i = o ? t : e; const r = document.createRange(); r.setStart(n, 0), r.setEnd(i, 0); const p = r.commonAncestorContainer; if (e !== p && t !== p || n.contains(i)) {
    return g(p) ? p : c(p)
  } const s = u(e); return s.host ? b(s.host, t) : b(e, u(t).host)
} function w(e) {
  const t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'top'; const o = t === 'top' ? 'scrollTop' : 'scrollLeft'; const n = e.nodeName; if (n === 'BODY' || n === 'HTML') {
    const i = e.ownerDocument.documentElement; const r = e.ownerDocument.scrollingElement || i; return r[o]
  } return e[o]
} function y(e, t) {
  const o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const n = w(t, 'top'); const i = w(t, 'left'); const r = o ? -1 : 1; return e.top += n * r, e.bottom += n * r, e.left += i * r, e.right += i * r, e
} function E(e, t) {
  const o = t === 'x' ? 'Left' : 'Top'; const n = o == 'Left' ? 'Right' : 'Bottom'; return parseFloat(e[`border${o}Width`]) + parseFloat(e[`border${n}Width`])
} function x(e, t, o, n) {
  return Math.max(t[`offset${e}`], t[`scroll${e}`], o[`client${e}`], o[`offset${e}`], o[`scroll${e}`], h(10) ? parseInt(o[`offset${e}`]) + parseInt(n[`margin${e === 'Height' ? 'Top' : 'Left'}`]) + parseInt(n[`margin${e === 'Height' ? 'Bottom' : 'Right'}`]) : 0)
} function v(e) {
  const t = e.body; const o = e.documentElement; const n = h(10) && getComputedStyle(o); return {
    height:x('Height', t, o, n),
    width:x('Width', t, o, n)
  }
} const O = function (e, t) {
  if (!(e instanceof t)) {
    throw new TypeError('Cannot call a class as a function')
  }
}; const L = (function () {
  function e(e, t) {
    for (var n = 0, o; n < t.length; n++) {
      o = t[n], o.enumerable = o.enumerable || !1, o.configurable = !0, 'value' in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
    }
  } return function (t, o, n) {
    return o && e(t.prototype, o), n && e(t, n), t
  }
}()); const S = function (e, t, o) {
  return t in e ? Object.defineProperty(e, t, {
    value:o,
    enumerable:!0,
    configurable:!0,
    writable:!0
  }) : e[t] = o, e
}; const T = Object.assign || function (e) {
  for (var o = 1, t; o < arguments.length; o++) {
    for (const n in t = arguments[o], t) {
      Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
    }
  } return e
}; function C(e) {
  return T({}, e, {
    right:e.left + e.width,
    bottom:e.top + e.height
  })
} function D(e) {
  let t = {}; try {
    if (h(10)) {
      t = e.getBoundingClientRect(); const o = w(e, 'top'); const n = w(e, 'left'); t.top += o, t.left += n, t.bottom += o, t.right += n
    } else {
      t = e.getBoundingClientRect()
    }
  } catch (t) {} const i = {
    left:t.left,
    top:t.top,
    width:t.right - t.left,
    height:t.bottom - t.top
  }; const r = e.nodeName === 'HTML' ? v(e.ownerDocument) : {}; const p = r.width || e.clientWidth || i.width; const d = r.height || e.clientHeight || i.height; let a = e.offsetWidth - p; let l = e.offsetHeight - d; if (a || l) {
    const f = s(e); a -= E(f, 'x'), l -= E(f, 'y'), i.width -= a, i.height -= l
  } return C(i)
} function N(e, t) {
  const o = Math.max; const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const i = h(10); const r = t.nodeName === 'HTML'; const p = D(e); const d = D(t); const l = a(e); const f = s(t); const m = parseFloat(f.borderTopWidth); const c = parseFloat(f.borderLeftWidth); n && r && (d.top = o(d.top, 0), d.left = o(d.left, 0)); let g = C({
    top:p.top - d.top - m,
    left:p.left - d.left - c,
    width:p.width,
    height:p.height
  }); if (g.marginTop = 0, g.marginLeft = 0, !i && r) {
    const u = parseFloat(f.marginTop); const b = parseFloat(f.marginLeft); g.top -= m - u, g.bottom -= m - u, g.left -= c - b, g.right -= c - b, g.marginTop = u, g.marginLeft = b
  } return (i && !n ? t.contains(l) : t === l && l.nodeName !== 'BODY') && (g = y(g, t)), g
} function P(e) {
  const t = Math.max; const o = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = e.ownerDocument.documentElement; const i = N(e, n); const r = t(n.clientWidth, window.innerWidth || 0); const p = t(n.clientHeight, window.innerHeight || 0); const s = o ? 0 : w(n); const d = o ? 0 : w(n, 'left'); const a = {
    top:s - i.top + i.marginTop,
    left:d - i.left + i.marginLeft,
    width:r,
    height:p
  }; return C(a)
} function k(e) {
  const t = e.nodeName; if (t === 'BODY' || t === 'HTML') {
    return !1
  } if (s(e, 'position') === 'fixed') {
    return !0
  } const o = d(e); return Boolean(o) && k(o)
} function W(e) {
  if (!e || !e.parentElement || h()) {
    return document.documentElement
  } for (var t = e.parentElement; t && s(t, 'transform') === 'none';) {
    t = t.parentElement
  } return t || document.documentElement
} function B(e, t, o, n) {
  const i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; let r = {
    top:0,
    left:0
  }; const p = i ? W(e) : b(e, l(t)); if (n === 'viewport') {
    r = P(p, i)
  } else {
    let s; n === 'scrollParent' ? (s = a(d(t)), s.nodeName === 'BODY' && (s = e.ownerDocument.documentElement)) : n === 'window' ? s = e.ownerDocument.documentElement : s = n; const f = N(s, p, i); if (s.nodeName === 'HTML' && !k(p)) {
      const m = v(e.ownerDocument); const h = m.height; const c = m.width; r.top += f.top - f.marginTop, r.bottom = h + f.top, r.left += f.left - f.marginLeft, r.right = c + f.left
    } else {
      r = f
    }
  }o = o || 0; const g = typeof o === 'number'; return r.left += g ? o : o.left || 0, r.top += g ? o : o.top || 0, r.right -= g ? o : o.right || 0, r.bottom -= g ? o : o.bottom || 0, r
} function H(e) {
  const t = e.width; const o = e.height; return t * o
} function A(e, t, o, n, i) {
  const r = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0; if (e.indexOf('auto') === -1) {
    return e
  } const p = B(o, n, r, i); const s = {
    top:{
      width:p.width,
      height:t.top - p.top
    },
    right:{
      width:p.right - t.right,
      height:p.height
    },
    bottom:{
      width:p.width,
      height:p.bottom - t.bottom
    },
    left:{
      width:t.left - p.left,
      height:p.height
    }
  }; const d = Object.keys(s).map((e) => T({
    key:e
  }, s[e], {
    area:H(s[e])
  })).sort((e, t) => t.area - e.area); const a = d.filter((e) => {
    const t = e.width; const n = e.height; return t >= o.clientWidth && n >= o.clientHeight
  }); const l = a.length > 0 ? a[0].key : d[0].key; const f = e.split('-')[1]; return l + (f ? `-${f}` : '')
} function M(e, t, o) {
  const n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null; const i = n ? W(t) : b(t, l(o)); return N(o, i, n)
} function F(e) {
  const t = e.ownerDocument.defaultView; const o = t.getComputedStyle(e); const n = parseFloat(o.marginTop || 0) + parseFloat(o.marginBottom || 0); const i = parseFloat(o.marginLeft || 0) + parseFloat(o.marginRight || 0); const r = {
    width:e.offsetWidth + i,
    height:e.offsetHeight + n
  }; return r
} function I(e) {
  const t = {
    left:'right',
    right:'left',
    bottom:'top',
    top:'bottom'
  }; return e.replace(/left|right|bottom|top/g, (e) => t[e])
} function R(e, t, o) {
  o = o.split('-')[0]; const n = F(e); const i = {
    width:n.width,
    height:n.height
  }; const r = ['right', 'left'].indexOf(o) !== -1; const p = r ? 'top' : 'left'; const s = r ? 'left' : 'top'; const d = r ? 'height' : 'width'; const a = r ? 'width' : 'height'; return i[p] = t[p] + t[d] / 2 - n[d] / 2, i[s] = o === s ? t[s] - n[a] : t[I(s)], i
} function U(e, t) {
  return Array.prototype.find ? e.find(t) : e.filter(t)[0]
} function Y(e, t, o) {
  if (Array.prototype.findIndex) {
    return e.findIndex((e) => e[t] === o)
  } const n = U(e, (e) => e[t] === o); return e.indexOf(n)
} function V(e, t, o) {
  const n = void 0 === o ? e : e.slice(0, Y(e, 'name', o)); return n.forEach((e) => {
    e.function && console.warn('`modifier.function` is deprecated, use `modifier.fn`!'); const o = e.function || e.fn; e.enabled && p(o) && (t.offsets.popper = C(t.offsets.popper), t.offsets.reference = C(t.offsets.reference), t = o(t, e))
  }), t
} function j() {
  if (!this.state.isDestroyed) {
    let e = {
      instance:this,
      styles:{},
      arrowStyles:{},
      attributes:{},
      flipped:!1,
      offsets:{}
    }; e.offsets.reference = M(this.state, this.popper, this.reference, this.options.positionFixed), e.placement = A(this.options.placement, e.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.positionFixed = this.options.positionFixed, e.offsets.popper = R(this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute', e = V(this.modifiers, e), this.state.isCreated ? this.options.onUpdate(e) : (this.state.isCreated = !0, this.options.onCreate(e))
  }
} function q(e, t) {
  return e.some((e) => {
    const o = e.name; const n = e.enabled; return n && o === t
  })
} function K(e) {
  for (let t = [!1, 'ms', 'Webkit', 'Moz', 'O'], o = e.charAt(0).toUpperCase() + e.slice(1), n = 0; n < t.length; n++) {
    const i = t[n]; const r = i ? String(i) + o : e; if (typeof document.body.style[r] !== 'undefined') {
      return r
    }
  } return null
} function z() {
  return this.state.isDestroyed = !0, q(this.modifiers, 'applyStyle') && (this.popper.removeAttribute('x-placement'), this.popper.style.position = '', this.popper.style.top = '', this.popper.style.left = '', this.popper.style.right = '', this.popper.style.bottom = '', this.popper.style.willChange = '', this.popper.style[K('transform')] = ''), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this
} function G(e) {
  const t = e.ownerDocument; return t ? t.defaultView : window
} function _(e, t, o, n) {
  const i = e.nodeName === 'BODY'; const r = i ? e.ownerDocument.defaultView : e; r.addEventListener(t, o, {
    passive:!0
  }), i || _(a(r.parentNode), t, o, n), n.push(r)
} function X(e, t, o, n) {
  o.updateBound = n, G(e).addEventListener('resize', o.updateBound, {
    passive:!0
  }); const i = a(e); return _(i, 'scroll', o.updateBound, o.scrollParents), o.scrollElement = i, o.eventsEnabled = !0, o
} function J() {
  this.state.eventsEnabled || (this.state = X(this.reference, this.options, this.state, this.scheduleUpdate))
} function Q(e, t) {
  return G(e).removeEventListener('resize', t.updateBound), t.scrollParents.forEach((e) => {
    e.removeEventListener('scroll', t.updateBound)
  }), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled = !1, t
} function Z() {
  this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = Q(this.reference, this.state))
} function $(e) {
  return e !== '' && !isNaN(parseFloat(e)) && isFinite(e)
} function ee(e, t) {
  Object.keys(t).forEach((o) => {
    let n = ''; ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(o) !== -1 && $(t[o]) && (n = 'px'), e.style[o] = t[o] + n
  })
} function te(e, t) {
  Object.keys(t).forEach((o) => {
    const n = t[o]; !1 === n ? e.removeAttribute(o) : e.setAttribute(o, t[o])
  })
} function oe(e) {
  return ee(e.instance.popper, e.styles), te(e.instance.popper, e.attributes), e.arrowElement && Object.keys(e.arrowStyles).length && ee(e.arrowElement, e.arrowStyles), e
} function ne(e, t, o, n, i) {
  const r = M(i, t, e, o.positionFixed); const p = A(o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); return t.setAttribute('x-placement', p), ee(t, {
    position:o.positionFixed ? 'fixed' : 'absolute'
  }), o
} function ie(e, t) {
  const o = e.offsets; const n = o.popper; const i = o.reference; const r = Math.round; const p = Math.floor; const s = function (e) {
    return e
  }; const d = r(i.width); const a = r(n.width); const l = ['left', 'right'].indexOf(e.placement) !== -1; const f = e.placement.indexOf('-') !== -1; const m = t ? l || f || d % 2 == a % 2 ? r : p : s; const h = t ? r : s; return {
    left:m(d % 2 == 1 && a % 2 == 1 && !f && t ? n.left - 1 : n.left),
    top:h(n.top),
    bottom:h(n.bottom),
    right:m(n.right)
  }
} const re = e && /Firefox/i.test(navigator.userAgent); function pe(e, t) {
  const o = t.x; const n = t.y; const i = e.offsets.popper; const r = U(e.instance.modifiers, (e) => e.name === 'applyStyle').gpuAcceleration; void 0 !== r && console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!'); let p; let s; const d = void 0 === r ? t.gpuAcceleration : r; const a = c(e.instance.popper); const l = D(a); const f = {
    position:i.position
  }; const m = ie(e, window.devicePixelRatio < 2 || !re); const h = o === 'bottom' ? 'top' : 'bottom'; const g = n === 'right' ? 'left' : 'right'; const u = K('transform'); if (s = h == 'bottom' ? a.nodeName === 'HTML' ? -a.clientHeight + m.bottom : -l.height + m.bottom : m.top, p = g == 'right' ? a.nodeName === 'HTML' ? -a.clientWidth + m.right : -l.width + m.right : m.left, d && u) {
    f[u] = `translate3d(${p}px, ${s}px, 0)`, f[h] = 0, f[g] = 0, f.willChange = 'transform'
  } else {
    const b = h == 'bottom' ? -1 : 1; const w = g == 'right' ? -1 : 1; f[h] = s * b, f[g] = p * w, f.willChange = `${h}, ${g}`
  } const y = {
    'x-placement':e.placement
  }; return e.attributes = T({}, y, e.attributes), e.styles = T({}, f, e.styles), e.arrowStyles = T({}, e.offsets.arrow, e.arrowStyles), e
} function se(e, t, o) {
  const n = U(e, (e) => {
    const o = e.name; return o === t
  }); const i = Boolean(n) && e.some((e) => e.name === o && e.enabled && e.order < n.order); if (!i) {
    const r = `\`${t}\``; console.warn(`\`${o}\`` + ` modifier is required by ${r} modifier in order to work, be sure to include it before ${r}!`)
  } return i
} function de(e, t) {
  let o; if (!se(e.instance.modifiers, 'arrow', 'keepTogether')) {
    return e
  } let n = t.element; if (typeof n === 'string') {
    if (n = e.instance.popper.querySelector(n), !n) {
      return e
    }
  } else if (!e.instance.popper.contains(n)) {
    return console.warn('WARNING: `arrow.element` must be child of its popper element!'), e
  } const i = e.placement.split('-')[0]; const r = e.offsets; const p = r.popper; const d = r.reference; const a = ['left', 'right'].indexOf(i) !== -1; const l = a ? 'height' : 'width'; const f = a ? 'Top' : 'Left'; const m = f.toLowerCase(); const h = a ? 'left' : 'top'; const c = a ? 'bottom' : 'right'; const g = F(n)[l]; d[c] - g < p[m] && (e.offsets.popper[m] -= p[m] - (d[c] - g)), d[m] + g > p[c] && (e.offsets.popper[m] += d[m] + g - p[c]), e.offsets.popper = C(e.offsets.popper); const u = d[m] + d[l] / 2 - g / 2; const b = s(e.instance.popper); const w = parseFloat(b[`margin${f}`]); const y = parseFloat(b[`border${f}Width`]); let E = u - e.offsets.popper[m] - w - y; return E = Math.max(Math.min(p[l] - g, E), 0), e.arrowElement = n, e.offsets.arrow = (o = {}, S(o, m, Math.round(E)), S(o, h, ''), o), e
} function ae(e) {
  if (e === 'end') {
    return 'start'
  } return e === 'start' ? 'end' : e
} const le = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; const fe = le.slice(3); function me(e) {
  const t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1]; const o = fe.indexOf(e); const n = fe.slice(o + 1).concat(fe.slice(0, o)); return t ? n.reverse() : n
} const he = {
  FLIP:'flip',
  CLOCKWISE:'clockwise',
  COUNTERCLOCKWISE:'counterclockwise'
}; function ce(e, t) {
  if (q(e.instance.modifiers, 'inner')) {
    return e
  } if (e.flipped && e.placement === e.originalPlacement) {
    return e
  } const o = B(e.instance.popper, e.instance.reference, t.padding, t.boundariesElement, e.positionFixed); let n = e.placement.split('-')[0]; let i = I(n); let r = e.placement.split('-')[1] || ''; let p = []; switch (t.behavior) {
    case he.FLIP:p = [n, i]; break; case he.CLOCKWISE:p = me(n); break; case he.COUNTERCLOCKWISE:p = me(n, !0); break; default:p = t.behavior
  } return p.forEach((s, d) => {
    if (n !== s || p.length === d + 1) {
      return e
    } n = e.placement.split('-')[0], i = I(n); const a = e.offsets.popper; const l = e.offsets.reference; const f = Math.floor; const m = n === 'left' && f(a.right) > f(l.left) || n === 'right' && f(a.left) < f(l.right) || n === 'top' && f(a.bottom) > f(l.top) || n === 'bottom' && f(a.top) < f(l.bottom); const h = f(a.left) < f(o.left); const c = f(a.right) > f(o.right); const g = f(a.top) < f(o.top); const u = f(a.bottom) > f(o.bottom); const b = n === 'left' && h || n === 'right' && c || n === 'top' && g || n === 'bottom' && u; const w = ['top', 'bottom'].indexOf(n) !== -1; const y = Boolean(t.flipVariations) && (w && r === 'start' && h || w && r === 'end' && c || !w && r === 'start' && g || !w && r === 'end' && u); const E = Boolean(t.flipVariationsByContent) && (w && r === 'start' && c || w && r === 'end' && h || !w && r === 'start' && u || !w && r === 'end' && g); const x = y || E; (m || b || x) && (e.flipped = !0, (m || b) && (n = p[d + 1]), x && (r = ae(r)), e.placement = n + (r ? `-${r}` : ''), e.offsets.popper = T({}, e.offsets.popper, R(e.instance.popper, e.offsets.reference, e.placement)), e = V(e.instance.modifiers, e, 'flip'))
  }), e
} function ge(e) {
  const t = e.offsets; const o = t.popper; const n = t.reference; const i = e.placement.split('-')[0]; const r = Math.floor; const p = ['top', 'bottom'].indexOf(i) !== -1; const s = p ? 'right' : 'bottom'; const d = p ? 'left' : 'top'; const a = p ? 'width' : 'height'; return o[s] < r(n[d]) && (e.offsets.popper[d] = r(n[d]) - o[a]), o[d] > r(n[s]) && (e.offsets.popper[d] = r(n[s])), e
} function ue(e, t, o, n) {
  const i = Math.max; const r = e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/); const p = Number(r[1]); const s = r[2]; if (!p) {
    return e
  } if (s.indexOf('%') === 0) {
    let d; switch (s) {
      case '%p':d = o; break; case '%':case '%r':default:d = n
    } const a = C(d); return a[t] / 100 * p
  } if (s === 'vh' || s === 'vw') {
    let l; return l = s === 'vh' ? i(document.documentElement.clientHeight, window.innerHeight || 0) : i(document.documentElement.clientWidth, window.innerWidth || 0), l / 100 * p
  } return p
} function be(e, t, o, n) {
  const i = [0, 0]; const r = ['right', 'left'].indexOf(n) !== -1; const p = e.split(/(\+|\-)/).map((e) => e.trim()); const s = p.indexOf(U(p, (e) => e.search(/,|\s/) !== -1)); p[s] && p[s].indexOf(',') === -1 && console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.'); const d = /\s*,\s*|\s+/; let a = s === -1 ? [p] : [p.slice(0, s).concat([p[s].split(d)[0]]), [p[s].split(d)[1]].concat(p.slice(s + 1))]; return a = a.map((e, n) => {
    const i = (n === 1 ? !r : r) ? 'height' : 'width'; let p = !1; return e.reduce((e, t) => e[e.length-1]===''&&['+','-'].indexOf(t)!==-1?(e[e.length - 1] = t, p = !0, e):p ? (e[e.length - 1] += t, p = !1, e):e.concat(t), []).map((e) => ue(e, i, t, o))
  }), a.forEach((e, t) => {
    e.forEach((o, n) => {
      $(o) && (i[t] += o * (e[n - 1] === '-' ? -1 : 1))
    })
  }), i
} function we(e, t) {
  let o; const n = t.offset; const i = e.placement; const r = e.offsets; const p = r.popper; const s = r.reference; const d = i.split('-')[0]; return o = $(Number(n)) ? [Number(n), 0] : be(n, p, s, d), d === 'left' ? (p.top += o[0], p.left -= o[1]) : d === 'right' ? (p.top += o[0], p.left += o[1]) : d === 'top' ? (p.left += o[0], p.top -= o[1]) : d === 'bottom' && (p.left += o[0], p.top += o[1]), e.popper = p, e
} function ye(e, t) {
  let o = t.boundariesElement || c(e.instance.popper); e.instance.reference === o && (o = c(o)); const n = K('transform'); const i = e.instance.popper.style; const r = i.top; const p = i.left; const s = i[n]; i.top = '', i.left = '', i[n] = ''; const d = B(e.instance.popper, e.instance.reference, t.padding, o, e.positionFixed); i.top = r, i.left = p, i[n] = s, t.boundaries = d; const a = t.priority; let l = e.offsets.popper; const f = {
    primary(e) {
      let o = l[e]; return l[e] < d[e] && !t.escapeWithReference && (o = Math.max(l[e], d[e])), S({}, e, o)
    },
    secondary(e) {
      const o = e === 'right' ? 'left' : 'top'; let n = l[o]; return l[e] > d[e] && !t.escapeWithReference && (n = Math.min(l[o], d[e] - (e === 'right' ? l.width : l.height))), S({}, o, n)
    }
  }; return a.forEach((e) => {
    const t = ['left', 'top'].indexOf(e) === -1 ? 'secondary' : 'primary'; l = T({}, l, f[t](e))
  }), e.offsets.popper = l, e
} function Ee(e) {
  const t = e.placement; const o = t.split('-')[0]; const n = t.split('-')[1]; if (n) {
    const i = e.offsets; const r = i.reference; const p = i.popper; const s = ['bottom', 'top'].indexOf(o) !== -1; const d = s ? 'left' : 'top'; const a = s ? 'width' : 'height'; const l = {
      start:S({}, d, r[d]),
      end:S({}, d, r[d] + r[a] - p[a])
    }; e.offsets.popper = T({}, p, l[n])
  } return e
} function xe(e) {
  if (!se(e.instance.modifiers, 'hide', 'preventOverflow')) {
    return e
  } const t = e.offsets.reference; const o = U(e.instance.modifiers, (e) => e.name === 'preventOverflow').boundaries; if (t.bottom < o.top || t.left > o.right || t.top > o.bottom || t.right < o.left) {
    if (!0 === e.hide) {
      return e
    } e.hide = !0, e.attributes['x-out-of-boundaries'] = ''
  } else {
    if (!1 === e.hide) {
      return e
    } e.hide = !1, e.attributes['x-out-of-boundaries'] = !1
  } return e
} function ve(e) {
  const t = e.placement; const o = t.split('-')[0]; const n = e.offsets; const i = n.popper; const r = n.reference; const p = ['left', 'right'].indexOf(o) !== -1; const s = ['top', 'left'].indexOf(o) === -1; return i[p ? 'left' : 'top'] = r[o] - (s ? i[p ? 'width' : 'height'] : 0), e.placement = I(t), e.offsets.popper = C(i), e
} const Oe = {
  shift:{
    order:100,
    enabled:!0,
    fn:Ee
  },
  offset:{
    order:200,
    enabled:!0,
    fn:we,
    offset:0
  },
  preventOverflow:{
    order:300,
    enabled:!0,
    fn:ye,
    priority:['left', 'right', 'top', 'bottom'],
    padding:5,
    boundariesElement:'scrollParent'
  },
  keepTogether:{
    order:400,
    enabled:!0,
    fn:ge
  },
  arrow:{
    order:500,
    enabled:!0,
    fn:de,
    element:'[x-arrow]'
  },
  flip:{
    order:600,
    enabled:!0,
    fn:ce,
    behavior:'flip',
    padding:5,
    boundariesElement:'viewport',
    flipVariations:!1,
    flipVariationsByContent:!1
  },
  inner:{
    order:700,
    enabled:!1,
    fn:ve
  },
  hide:{
    order:800,
    enabled:!0,
    fn:xe
  },
  computeStyle:{
    order:850,
    enabled:!0,
    fn:pe,
    gpuAcceleration:!0,
    x:'bottom',
    y:'right'
  },
  applyStyle:{
    order:900,
    enabled:!0,
    fn:oe,
    onLoad:ne,
    gpuAcceleration:void 0
  }
}; const Le = {
  placement:'bottom',
  positionFixed:!1,
  eventsEnabled:!0,
  removeOnDestroy:!1,
  onCreate() {},
  onUpdate() {},
  modifiers:Oe
}; const Se = (function () {
  function e(t, o) {
    const n = this; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; O(this, e), this.scheduleUpdate = function () {
      return requestAnimationFrame(n.update)
    }, this.update = r(this.update.bind(this)), this.options = T({}, e.Defaults, i), this.state = {
      isDestroyed:!1,
      isCreated:!1,
      scrollParents:[]
    }, this.reference = t && t.jquery ? t[0] : t, this.popper = o && o.jquery ? o[0] : o, this.options.modifiers = {}, Object.keys(T({}, e.Defaults.modifiers, i.modifiers)).forEach((t) => {
      n.options.modifiers[t] = T({}, e.Defaults.modifiers[t] || {}, i.modifiers ? i.modifiers[t] : {})
    }), this.modifiers = Object.keys(this.options.modifiers).map((e) => T({
      name:e
    }, n.options.modifiers[e])).sort((e, t) => e.order - t.order), this.modifiers.forEach((e) => {
      e.enabled && p(e.onLoad) && e.onLoad(n.reference, n.popper, n.options, e, n.state)
    }), this.update(); const s = this.options.eventsEnabled; s && this.enableEventListeners(), this.state.eventsEnabled = s
  } return L(e, [{
    key:'update',
    value() {
      return j.call(this)
    }
  }, {
    key:'destroy',
    value() {
      return z.call(this)
    }
  }, {
    key:'enableEventListeners',
    value() {
      return J.call(this)
    }
  }, {
    key:'disableEventListeners',
    value() {
      return Z.call(this)
    }
  }]), e
}()); Se.Utils = (typeof window === 'undefined' ? global : window).PopperUtils, Se.placements = le, Se.Defaults = Le; export default Se
// # sourceMappingURL=popper.min.js.map
