/* !
 * OverlayScrollbars
 * https://github.com/KingSora/OverlayScrollbars
 *
 * Version: 1.11.0
 *
 * Copyright KingSora | Rene Haas.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 * Date: 29.02.2020
 */
!(function (n, t) {
  typeof define === 'function' && define.amd ? define(() => t(n, n.document, undefined)) : typeof module === 'object' && typeof module.exports === 'object' ? module.exports = t(n, n.document, undefined) : t(n, n.document, undefined)
}(typeof window !== 'undefined' ? window : this, (gt, mt, bi) => {
  let o; let a; let c; let u; const wt = 'object'; const yt = 'function'; const xt = 'array'; const _t = 'string'; const Ot = 'boolean'; const St = 'number'; const f = 'undefined'; const n = 'null'; const gi = {
    c:'class',
    s:'style',
    i:'id',
    l:'length',
    p:'prototype',
    ti:'tabindex',
    oH:'offsetHeight',
    cH:'clientHeight',
    sH:'scrollHeight',
    oW:'offsetWidth',
    cW:'clientWidth',
    sW:'scrollWidth',
    hOP:'hasOwnProperty',
    bCR:'getBoundingClientRect'
  }; const zt = (o = {}, a = {}, {
    e:c = ['-webkit-', '-moz-', '-o-', '-ms-'],
    u:u = ['WebKit', 'Moz', 'O', 'MS'],
    v(n) {
      let t = a[n]; if (a[gi.hOP](n)) {
        return t
      } for (var r, e, i, o = s(n), u = mt.createElement('div')[gi.s], f = 0; f < c.length; f++) {
        for (i = c[f].replace(/-/g, ''), r = [n, c[f] + n, i + o, s(i) + o], e = 0; e < r[gi.l]; e++) {
          if (u[r[e]] !== bi) {
            t = r[e]; break
          }
        }
      } return a[n] = t
    },
    d(n, t, r) {
      let e = 0; let i = o[n]; if (!o[gi.hOP](n)) {
        for (i = gt[n]; e < u[gi.l]; e++) {
          i = i || gt[(t ? u[e] : u[e].toLowerCase()) + s(n)]
        }o[n] = i
      } return i || r
    }
  }); function s(n) {
    return n.charAt(0).toUpperCase() + n.slice(1)
  } const mi = {
    wW:r(t, 0, !0),
    wH:r(t, 0),
    mO:r(zt.d, 0, 'MutationObserver', !0),
    rO:r(zt.d, 0, 'ResizeObserver', !0),
    rAF:r(zt.d, 0, 'requestAnimationFrame', !1, (n) => gt.setTimeout(n, 1e3 / 60)),
    cAF:r(zt.d, 0, 'cancelAnimationFrame', !1, (n) => gt.clearTimeout(n)),
    now() {
      return Date.now && Date.now() || new Date().getTime()
    },
    stpP(n) {
      n.stopPropagation ? n.stopPropagation() : n.cancelBubble = !0
    },
    prvD(n) {
      n.preventDefault && n.cancelable ? n.preventDefault() : n.returnValue = !1
    },
    page(n) {
      const t = 'page'; const r = 'client'; const e = 'X'; const i = ((n = n.originalEvent || n).target || n.srcElement || mt).ownerDocument || mt; const o = i.documentElement; const u = i.body; if (n.touches === bi) {
        return !n[t + e] && n[r + e] && n[r + e] != null ? {
          x:n[r + e] + (o && o.scrollLeft || u && u.scrollLeft || 0) - (o && o.clientLeft || u && u.clientLeft || 0),
          y:n[`${r}Y`] + (o && o.scrollTop || u && u.scrollTop || 0) - (o && o.clientTop || u && u.clientTop || 0)
        } : {
          x:n[t + e],
          y:n.pageY
        }
      } const f = n.touches[0]; return {
        x:f[t + e],
        y:f.pageY
      }
    },
    mBtn(n) {
      const t = n.button; return n.which || t === bi ? n.which : 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0
    },
    inA(n, t) {
      for (let r = 0; r < t[gi.l]; r++) {
        try {
          if (t[r] === n) {
            return r
          }
        } catch (e) {}
      } return -1
    },
    isA(n) {
      const t = Array.isArray; return t ? t(n) : this.type(n) == xt
    },
    type(n) {
      return n === bi || n === null ? `${n}` : Object[gi.p].toString.call(n).replace(/^\[object (.+)\]$/, '$1').toLowerCase()
    },
    bind:r
  }; function t(n) {
    return n ? gt.innerWidth || mt.documentElement[gi.cW] || mt.body[gi.cW] : gt.innerHeight || mt.documentElement[gi.cH] || mt.body[gi.cH]
  } function r(n, t) {
    if (typeof n !== yt) {
      throw 'Can\'t bind function!'
    } const r = gi.p; const e = Array[r].slice.call(arguments, 2); const i = function () {}; const o = function () {
      return n.apply(this instanceof i ? this : t, e.concat(Array[r].slice.call(arguments)))
    }; return n[r] && (i[r] = n[r]), o[r] = new i(), o
  } let l; let v; let h; let C; let I; let T; let d; let p; const wi = Math; const yi = gt.jQuery; const A = (l = {
    p:wi.PI,
    c:wi.cos,
    s:wi.sin,
    w:wi.pow,
    t:wi.sqrt,
    n:wi.asin,
    a:wi.abs,
    o:1.70158
  }, {
    swing(n, t, r, e, i) {
      return 0.5 - l.c(n * l.p) / 2
    },
    linear(n, t, r, e, i) {
      return n
    },
    easeInQuad(n, t, r, e, i) {
      return e * (t /= i) * t + r
    },
    easeOutQuad(n, t, r, e, i) {
      return -e * (t /= i) * (t - 2) + r
    },
    easeInOutQuad(n, t, r, e, i) {
      return (t /= i / 2) < 1 ? e / 2 * t * t + r : -e / 2 * (--t * (t - 2) - 1) + r
    },
    easeInCubic(n, t, r, e, i) {
      return e * (t /= i) * t * t + r
    },
    easeOutCubic(n, t, r, e, i) {
      return e * ((t = t / i - 1) * t * t + 1) + r
    },
    easeInOutCubic(n, t, r, e, i) {
      return (t /= i / 2) < 1 ? e / 2 * t * t * t + r : e / 2 * ((t -= 2) * t * t + 2) + r
    },
    easeInQuart(n, t, r, e, i) {
      return e * (t /= i) * t * t * t + r
    },
    easeOutQuart(n, t, r, e, i) {
      return -e * ((t = t / i - 1) * t * t * t - 1) + r
    },
    easeInOutQuart(n, t, r, e, i) {
      return (t /= i / 2) < 1 ? e / 2 * t * t * t * t + r : -e / 2 * ((t -= 2) * t * t * t - 2) + r
    },
    easeInQuint(n, t, r, e, i) {
      return e * (t /= i) * t * t * t * t + r
    },
    easeOutQuint(n, t, r, e, i) {
      return e * ((t = t / i - 1) * t * t * t * t + 1) + r
    },
    easeInOutQuint(n, t, r, e, i) {
      return (t /= i / 2) < 1 ? e / 2 * t * t * t * t * t + r : e / 2 * ((t -= 2) * t * t * t * t + 2) + r
    },
    easeInSine(n, t, r, e, i) {
      return -e * l.c(t / i * (l.p / 2)) + e + r
    },
    easeOutSine(n, t, r, e, i) {
      return e * l.s(t / i * (l.p / 2)) + r
    },
    easeInOutSine(n, t, r, e, i) {
      return -e / 2 * (l.c(l.p * t / i) - 1) + r
    },
    easeInExpo(n, t, r, e, i) {
      return t == 0 ? r : e * l.w(2, 10 * (t / i - 1)) + r
    },
    easeOutExpo(n, t, r, e, i) {
      return t == i ? r + e : e * (1 - l.w(2, -10 * t / i)) + r
    },
    easeInOutExpo(n, t, r, e, i) {
      return t == 0 ? r : t == i ? r + e : (t /= i / 2) < 1 ? e / 2 * l.w(2, 10 * (t - 1)) + r : e / 2 * (2 - l.w(2, -10 * --t)) + r
    },
    easeInCirc(n, t, r, e, i) {
      return -e * (l.t(1 - (t /= i) * t) - 1) + r
    },
    easeOutCirc(n, t, r, e, i) {
      return e * l.t(1 - (t = t / i - 1) * t) + r
    },
    easeInOutCirc(n, t, r, e, i) {
      return (t /= i / 2) < 1 ? -e / 2 * (l.t(1 - t * t) - 1) + r : e / 2 * (l.t(1 - (t -= 2) * t) + 1) + r
    },
    easeInElastic(n, t, r, e, i) {
      let o = l.o; let u = 0; let f = e; return t == 0 ? r : (t /= i) == 1 ? r + e : (u = u || 0.3 * i, o = f < l.a(e) ? (f = e, u / 4) : u / (2 * l.p) * l.n(e / f), -(f * l.w(2, 10 * --t) * l.s((t * i - o) * (2 * l.p) / u)) + r)
    },
    easeOutElastic(n, t, r, e, i) {
      let o = l.o; let u = 0; let f = e; return t == 0 ? r : (t /= i) == 1 ? r + e : (u = u || 0.3 * i, o = f < l.a(e) ? (f = e, u / 4) : u / (2 * l.p) * l.n(e / f), f * l.w(2, -10 * t) * l.s((t * i - o) * (2 * l.p) / u) + e + r)
    },
    easeInOutElastic(n, t, r, e, i) {
      let o = l.o; let u = 0; let f = e; return t == 0 ? r : (t /= i / 2) == 2 ? r + e : (u = u || i * (0.3 * 1.5), o = f < l.a(e) ? (f = e, u / 4) : u / (2 * l.p) * l.n(e / f), t < 1 ? f * l.w(2, 10 * --t) * l.s((t * i - o) * (2 * l.p) / u) * -0.5 + r : f * l.w(2, -10 * --t) * l.s((t * i - o) * (2 * l.p) / u) * 0.5 + e + r)
    },
    easeInBack(n, t, r, e, i, o) {
      return e * (t /= i) * t * (((o = o || l.o) + 1) * t - o) + r
    },
    easeOutBack(n, t, r, e, i, o) {
      return e * ((t = t / i - 1) * t * (((o = o || l.o) + 1) * t + o) + 1) + r
    },
    easeInOutBack(n, t, r, e, i, o) {
      return o = o || l.o, (t /= i / 2) < 1 ? e / 2 * (t * t * ((1 + (o *= 1.525)) * t - o)) + r : e / 2 * ((t -= 2) * t * ((1 + (o *= 1.525)) * t + o) + 2) + r
    },
    easeInBounce(n, t, r, e, i) {
      return e - this.easeOutBounce(n, i - t, 0, e, i) + r
    },
    easeOutBounce(n, t, r, e, i) {
      const o = 7.5625; return (t /= i) < 1 / 2.75 ? e * (o * t * t) + r : t < 2 / 2.75 ? e * (o * (t -= 1.5 / 2.75) * t + 0.75) + r : t < 2.5 / 2.75 ? e * (o * (t -= 2.25 / 2.75) * t + 0.9375) + r : e * (o * (t -= 2.625 / 2.75) * t + 0.984375) + r
    },
    easeInOutBounce(n, t, r, e, i) {
      return t < i / 2 ? 0.5 * this.easeInBounce(n, 2 * t, 0, e, i) + r : 0.5 * this.easeOutBounce(n, 2 * t - i, 0, e, i) + 0.5 * e + r
    }
  }); const xi = (v = /[^\x20\t\r\n\f]+/g, h = ' ', C = 'scrollLeft', I = 'scrollTop', T = [], d = mi.type, p = {
    animationIterationCount:!0,
    columnCount:!0,
    fillOpacity:!0,
    flexGrow:!0,
    flexShrink:!0,
    fontWeight:!0,
    lineHeight:!0,
    opacity:!0,
    order:!0,
    orphans:!0,
    widows:!0,
    zIndex:!0,
    zoom:!0
  }, D[gi.p] = {
    on(t, r) {
      let e; const i = (t = (t || '').match(v) || [''])[gi.l]; let o = 0; return this.each(function () {
        e = this; try {
          if (e.addEventListener) {
            for (;o < i; o++) {
              e.addEventListener(t[o], r)
            }
          } else if (e.detachEvent) {
            for (;o < i; o++) {
              e.attachEvent(`on${t[o]}`, r)
            }
          }
        } catch (n) {}
      })
    },
    off(t, r) {
      let e; const i = (t = (t || '').match(v) || [''])[gi.l]; let o = 0; return this.each(function () {
        e = this; try {
          if (e.removeEventListener) {
            for (;o < i; o++) {
              e.removeEventListener(t[o], r)
            }
          } else if (e.detachEvent) {
            for (;o < i; o++) {
              e.detachEvent(`on${t[o]}`, r)
            }
          }
        } catch (n) {}
      })
    },
    one(n, i) {
      return n = (n || '').match(v) || [''], this.each(function () {
        const e = D(this); D.each(n, (n, t) => {
          var r = function (n) {
            i.call(this, n), e.off(t, r)
          }; e.on(t, r)
        })
      })
    },
    trigger(n) {
      let r; let t; return this.each(function () {
        t = this, mt.createEvent ? ((r = mt.createEvent('HTMLEvents')).initEvent(n, !0, !1), t.dispatchEvent(r)) : t.fireEvent(`on${n}`)
      })
    },
    append(n) {
      return this.each(function () {
        i(this, 'beforeend', n)
      })
    },
    prepend(n) {
      return this.each(function () {
        i(this, 'afterbegin', n)
      })
    },
    before(n) {
      return this.each(function () {
        i(this, 'beforebegin', n)
      })
    },
    after(n) {
      return this.each(function () {
        i(this, 'afterend', n)
      })
    },
    remove() {
      return this.each(function () {
        const n = this.parentNode; n != null && n.removeChild(this)
      })
    },
    unwrap() {
      let n; let t; let r; const e = []; for (this.each(function () {
        H(r = this.parentNode, e) === -1 && e.push(r)
      }), n = 0; n < e[gi.l]; n++) {
        for (t = e[n], r = t.parentNode; t.firstChild;) {
          r.insertBefore(t.firstChild, t)
        }r.removeChild(t)
      } return this
    },
    wrapAll(n) {
      for (var t, r = this, e = D(n)[0], i = e, o = r[0].parentNode, u = r[0].previousSibling; i.childNodes[gi.l] > 0;) {
        i = i.childNodes[0]
      } for (t = 0; r[gi.l] - t; i.firstChild === r[0] && t++) {
        i.appendChild(r[t])
      } const f = u ? u.nextSibling : o.firstChild; return o.insertBefore(e, f), this
    },
    wrapInner(r) {
      return this.each(function () {
        const n = D(this); const t = n.contents(); t[gi.l] ? t.wrapAll(r) : n.append(r)
      })
    },
    wrap(n) {
      return this.each(function () {
        D(this).wrapAll(n)
      })
    },
    css(n, t) {
      let r; let e; let i; const o = gt.getComputedStyle; return d(n) == _t ? t === bi ? (r = this[0], i = o ? o(r, null) : r.currentStyle[n], o ? i != null ? i.getPropertyValue(n) : r[gi.s][n] : i) : this.each(function () {
        y(this, n, t)
      }) : this.each(function () {
        for (e in n) {
          y(this, e, n[e])
        }
      })
    },
    hasClass(n) {
      for (var t, r, e = 0, i = h + n + h; t = this[e++];) {
        if ((r = t.classList) && r.contains(n)) {
          return !0
        } if (t.nodeType === 1 && (h + m(`${t.className}`) + h).indexOf(i) > -1) {
          return !0
        }
      } return !1
    },
    addClass(n) {
      let a; let c = 0; let e; let f; let i; let o; let r; let s = 0; let t; let u; if (n) {
        for (t = n.match(v) || []; r = this[c++];) {
          if (a = r.classList, f === bi && (f = a !== bi), f) {
            for (;o = t[s++];) {
              a.add(o) 
} 
} else if (i = `${r.className}`, e = r.nodeType === 1 && h + m(i) + h) {
            for (;o = t[s++];) {
              e.indexOf(h + o + h) < 0 && (e += o + h)
            }i !== (u = m(e)) && (r.className = u)
          }
        }
      } return this
    },
    removeClass(n) {
      let a; let c = 0; let e; let f; let i; let o; let r; let s = 0; let t; let u; if (n) {
        for (t = n.match(v) || []; r = this[c++];) {
          if (a = r.classList, f === bi && (f = a !== bi), f) {
            for (;o = t[s++];) {
              a.remove(o) 
} 
} else if (i = `${r.className}`, e = r.nodeType === 1 && h + m(i) + h) {
            for (;o = t[s++];) {
              for (;e.indexOf(h + o + h) > -1;) {
                e = e.replace(h + o + h, h) 
} 
}i !== (u = m(e)) && (r.className = u)
          }
        }
      } return this
    },
    hide() {
      return this.each(function () {
        this[gi.s].display = 'none'
      })
    },
    show() {
      return this.each(function () {
        this[gi.s].display = 'block'
      })
    },
    attr(n, t) {
      for (var e = 0, r; r = this[e++];) {
        if (t === bi) {
          return r.getAttribute(n)
        } r.setAttribute(n, t)
      } return this
    },
    removeAttr(n) {
      return this.each(function () {
        this.removeAttribute(n)
      })
    },
    offset() {
      const n = this[0][gi.bCR](); const t = gt.pageXOffset || mt.documentElement[C]; const r = gt.pageYOffset || mt.documentElement[I]; return {
        top:n.top + r,
        left:n.left + t
      }
    },
    position() {
      const n = this[0]; return {
        top:n.offsetTop,
        left:n.offsetLeft
      }
    },
    scrollLeft(n) {
      for (var r = 0, t; t = this[r++];) {
        if (n === bi) {
          return t[C]
        } t[C] = n
      } return this
    },
    scrollTop(n) {
      for (var r = 0, t; t = this[r++];) {
        if (n === bi) {
          return t[I]
        } t[I] = n
      } return this
    },
    val(n) {
      const t = this[0]; return n ? (t.value = n, this) : t.value
    },
    first() {
      return this.eq(0)
    },
    last() {
      return this.eq(-1)
    },
    eq(n) {
      return D(this[n >= 0 ? n : this[gi.l] + n])
    },
    find(t) {
      let r; const e = []; return this.each(function () {
        const n = this.querySelectorAll(t); for (r = 0; r < n[gi.l]; r++) {
          e.push(n[r])
        }
      }), D(e)
    },
    children(n) {
      let t; let r; let e; const i = []; return this.each(function () {
        for (r = this.children, e = 0; e < r[gi.l]; e++) {
          t = r[e], (!n || t.matches && t.matches(n) || w(t, n)) && i.push(t)
        }
      }), D(i)
    },
    parent(n) {
      let t; const r = []; return this.each(function () {
        t = this.parentNode, n && !D(t).is(n) || r.push(t)
      }), D(r)
    },
    is(n) {
      let r; let t; for (r = 0; r < this[gi.l]; r++) {
        if (t = this[r], n === ':visible') {
          return _(t)
        } if (n === ':hidden') {
          return !_(t)
        } if (t.matches && t.matches(n) || w(t, n)) {
          return !0
        }
      } return !1
    },
    contents() {
      let n; let t; const r = []; return this.each(function () {
        for (n = this.childNodes, t = 0; t < n[gi.l]; t++) {
          r.push(n[t])
        }
      }), D(r)
    },
    each(n) {
      return e(this, n)
    },
    animate(n, t, r, e) {
      return this.each(function () {
        x(this, n, t, r, e)
      })
    },
    stop(n, t) {
      return this.each(function () {
        !(function f(n, t, r) {
          for (var e, i, o, u = 0; u < T[gi.l]; u++) {
            if ((e = T[u]).el === n) {
              if (e.q[gi.l] > 0) {
                if ((i = e.q[0]).stop = !0, mi.cAF()(i.frame), e.q.splice(0, 1), r) {
                  for (o in i.props) {
                    W(n, o, i.props[o]) 
} 
}t ? e.q = [] : R(e, !1)
              } break
            }
          }
        }(this, n, t))
      })
    }
  }, b(D, {
    extend:b,
    inArray:H,
    isEmptyObject:L,
    isPlainObject:N,
    each:e
  }), D); function b() {
    let n; let t; let r; let e; let i; let o; let u = arguments[0] || {}; let f = 1; const a = arguments[gi.l]; let c = !1; for (d(u) == Ot && (c = u, u = arguments[1] || {}, f = 2), d(u) != wt && !d(u) == yt && (u = {}), a === f && (u = D, --f); f < a; f++) {
      if ((i = arguments[f]) != null) {
        for (e in i) {
          n = u[e], u !== (r = i[e]) && (c && r && (N(r) || (t = mi.isA(r))) ? (o = t ? (t = !1, n && mi.isA(n) ? n : []) : n && N(n) ? n : {}, u[e] = b(c, o, r)) : r !== bi && (u[e] = r))
        }
      }
    } return u
  } function H(n, t, r) {
    for (let e = r || 0; e < t[gi.l]; e++) {
      if (t[e] === n) {
        return e
      }
    } return -1
  } function E(n) {
    return d(n) == yt
  } function L(n) {
    for (const t in n) {
      return !1
    } return !0
  } function N(n) {
    if (!n || d(n) != wt) {
      return !1
    } let t; const r = gi.p; const e = Object[r].hasOwnProperty; const i = e.call(n, 'constructor'); const o = n.constructor && n.constructor[r] && e.call(n.constructor[r], 'isPrototypeOf'); if (n.constructor && !i && !o) {
      return !1
    } for (t in n) { } return d(t) == f || e.call(n, t)
  } function e(n, t) {
    let r = 0; if (g(n)) {
      for (;r < n[gi.l] && !1 !== t.call(n[r], r, n[r]); r++) { }
    } else {
      for (r in n) {
        if (!1 === t.call(n[r], r, n[r])) {
          break
        }
      }
    } return n
  } function g(n) {
    const t = Boolean(n) && [gi.l] in n && n[gi.l]; const r = d(n); return !E(r) && (r == xt || t === 0 || d(t) == St && t > 0 && t - 1 in n)
  } function m(n) {
    return (n.match(v) || []).join(h)
  } function w(n, t) {
    for (let r = (n.parentNode || mt).querySelectorAll(t) || [], e = r[gi.l]; e--;) {
      if (r[e] == n) {
        return 1
      }
    }
  } function i(n, t, r) {
    if (d(r) == xt) {
      for (let e = 0; e < r[gi.l]; e++) {
        i(n, t, r[e])
      }
    } else {
      d(r) == _t ? n.insertAdjacentHTML(t, r) : n.insertAdjacentElement(t, r.nodeType ? r : r[0])
    }
  } function y(n, t, r) {
    try {
      n[gi.s][t] !== bi && (n[gi.s][t] = (function e(n, t) {
        p[n.toLowerCase()] || d(t) != St || (t += 'px'); return t
      }(t, r)))
    } catch (i) {}
  } function R(n, t) {
    let e; let r; !1 !== t && n.q.splice(0, 1), n.q[gi.l] > 0 ? (e = n.q[0], x(n.el, e.props, e.duration, e.easing, e.complete, !0)) : (r = H(n, T)) > -1 && T.splice(r, 1)
  } function W(n, t, r) {
    t === C || t === I ? n[t] = r : y(n, t, r)
  } function x(n, t, r, e, i, o) {
    let u; let f; let a; let c; let s; let l; const v = N(r); const h = {}; const d = {}; let p = 0; for (l = v ? (e = r.easing, r.start, a = r.progress, c = r.step, s = r.specialEasing, i = r.complete, r.duration) : r, s = s || {}, l = l || 400, e = e || 'swing', o = o || !1; p < T[gi.l]; p++) {
      if (T[p].el === n) {
        f = T[p]; break
      }
    } for (u in f || (f = {
      el:n,
      q:[]
    }, T.push(f)), t) {
      h[u] = u === C || u === I ? n[u] : D(n).css(u)
    } for (u in h) {
      h[u] !== t[u] && t[u] !== bi && (d[u] = t[u])
    } if (L(d)) {
      o && R(f)
    } else {
      let b; let g; let m; let w; let y; let x; let _; let O; let S; let z = o ? 0 : H(k, f.q); var k = {
        props:d,
        duration:v ? r : l,
        easing:e,
        complete:i
      }; if (z === -1 && (z = f.q[gi.l], f.q.push(k)), z === 0) {
        if (l > 0) {
          _ = mi.now(), O = function () {
            for (u in b = mi.now(), S = b - _, g = k.stop || l <= S, m = 1 - (wi.max(0, _ + l - b) / l || 0), d) {
              w = parseFloat(h[u]), y = parseFloat(d[u]), x = (y - w) * A[s[u] || e](m, m * l, 0, 1, l) + w, W(n, u, x), E(c) && c(x, {
                elem:n,
                prop:u,
                start:w,
                now:x,
                end:y,
                pos:m,
                options:{
                  easing:e,
                  speacialEasing:s,
                  duration:l,
                  complete:i,
                  step:c
                },
                startTime:_
              })
            }E(a) && a({}, m, wi.max(0, l - S)), g ? (R(f), E(i) && i()) : k.frame = mi.rAF()(O)
          }, k.frame = mi.rAF()(O)
        } else {
          for (u in d) {
            W(n, u, d[u])
          }R(f)
        }
      }
    }
  } function _(n) {
    return Boolean(n[gi.oW] || n[gi.oH] || n.getClientRects()[gi.l])
  } function D(n) {
    if (arguments[gi.l] === 0) {
      return this
    } let t; let r; const e = new D(); let i = n; let o = 0; if (d(n) == _t) {
      for (i = [], t = n.charAt(0) === '<' ? ((r = mt.createElement('div')).innerHTML = n, r.children) : mt.querySelectorAll(n); o < t[gi.l]; o++) {
        i.push(t[o])
      }
    } if (i) {
      for (d(i) == _t || g(i) && i !== gt && i !== i.self || (i = [i]), o = 0; o < i[gi.l]; o++) {
        e[o] = i[o]
      }e[gi.l] = i[gi.l]
    } return e
  } let O; let S; let _i; let z; let k; let M; let F; let j; let P; let B; let Q; let U; let V; let q; let Oi; const Si = (O = [], S = '__overlayScrollbars__', function (n, t) {
    const r = arguments[gi.l]; if (r < 1) {
      return O
    } if (t) {
      n[S] = t, O.push(n)
    } else {
      const e = mi.inA(n, O); if (e > -1) {
        if (!(r > 1)) {
          return O[e][S]
        } delete n[S], O.splice(e, 1)
      }
    }
  }); const X = (q = [], M = mi.type, U = {
    className:['os-theme-dark', [n, _t]],
    resize:['none', 'n:none b:both h:horizontal v:vertical'],
    sizeAutoCapable:j = [!0, Ot],
    clipAlways:j,
    normalizeRTL:j,
    paddingAbsolute:P = [!(F = [Ot, St, _t, xt, wt, yt, n]), Ot],
    autoUpdate:[null, [n, Ot]],
    autoUpdateInterval:[33, St],
    nativeScrollbarsOverlaid:{
      showNativeScrollbars:P,
      initialize:j
    },
    overflowBehavior:{
      x:['scroll', Q = 'v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden'],
      y:['scroll', Q]
    },
    scrollbars:{
      visibility:['auto', 'v:visible h:hidden a:auto'],
      autoHide:['never', 'n:never s:scroll l:leave m:move'],
      autoHideDelay:[800, St],
      dragScrolling:j,
      clickScrolling:P,
      touchSupport:j,
      snapHandle:P
    },
    textarea:{
      dynWidth:P,
      dynHeight:P,
      inheritedAttrs:[['style', 'class'], [_t, xt, n]]
    },
    callbacks:{
      onInitialized:B = [null, [n, yt]],
      onInitializationWithdrawn:B,
      onDestroyed:B,
      onScrollStart:B,
      onScroll:B,
      onScrollStop:B,
      onOverflowChanged:B,
      onOverflowAmountChanged:B,
      onDirectionChanged:B,
      onContentSizeChanged:B,
      onHostSizeChanged:B,
      onUpdated:B
    }
  }, Oi = {
    g:(V = function (i) {
      var o = function (n) {
        let e; let r; let t; for (t in n) {
          n[gi.hOP](t) && (r = n[t], (e = M(r)) == xt ? n[t] = r[i ? 1 : 0] : e == wt && (n[t] = o(r)))
        } return n
      }; return o(xi.extend(!0, {}, U))
    })(),
    m:V(!0),
    _(n, t, I, r) {
      const e = {}; const i = {}; const o = xi.extend(!0, {}, n); const T = xi.inArray; const A = xi.isEmptyObject; var H = function (n, t, r, e, i, o) {
        for (var u in t) {
          if (t[gi.hOP](u) && n[gi.hOP](u)) {
            var f; var a; var c; var s; var l; var v; var h; var d; let p = !1; let b = !1; const g = t[u]; let m = M(g); const w = m == wt; const y = M(g) != xt ? [g] : g; let x = r[u]; const _ = n[u]; const O = M(_); const S = o ? `${o}.` : ''; const z = `The option "${S}${u}" wasn't set, because`; const k = []; let C = []; if (x = x === bi ? {} : x, w && O == wt) {
              e[u] = {}, i[u] = {}, H(_, g, x, e[u], i[u], S + u), xi.each([n, e, i], (n, t) => {
                A(t[u]) && delete t[u]
              })
            } else if (!w) {
              for (v = 0; v < y[gi.l]; v++) {
                if (l = y[v], c = (m = M(l)) == _t && T(l, F) === -1) {
                  for (k.push(_t), f = l.split(' '), C = C.concat(f), h = 0; h < f[gi.l]; h++) {
                    for (s = (a = f[h].split(':'))[0], d = 0; d < a[gi.l]; d++) {
 if (_ === a[d]) {
                      p = !0; break
                    } 
} if (p) {
 break 
}
                  }
                } else if (k.push(l), O === l) {
                  p = !0; break
                }
              }p ? ((b = _ !== x) && (e[u] = _), (c ? T(x, a) < 0 : b) && (i[u] = c ? s : _)) : I && console.warn(`${z} it doesn't accept the type [ ${O.toUpperCase()} ] with the value of "${_}".\r\nAccepted types are: [ ${k.join(', ').toUpperCase()} ].${C[length] > 0 ? `\r\nValid strings are: [ ${C.join(', ').split(':').join(', ')} ].` : ''}`), delete n[u]
            }
          }
        }
      }; return H(o, t, r || {}, e, i), !A(o) && I && console.warn(`The following options are discarded due to invalidity:\r\n${gt.JSON.stringify(o, null, 2)}`), {
        O:e,
        S:i
      }
    }
  }, (_i = gt.OverlayScrollbars = function (n, r, e) {
    if (arguments[gi.l] === 0) {
      return this
    } let i; let t; const o = []; const u = xi.isPlainObject(r); return n ? (n = n[gi.l] != bi ? n : [n[0] || n], Y(), n[gi.l] > 0 && (u ? xi.each(n, (n, t) => {
      (i = t) !== bi && o.push(K(i, r, e, z, k))
    }) : xi.each(n, (n, t) => {
      i = Si(t), (r === '!' && _i.valid(i) || mi.type(r) == yt && r(t, i) || r === bi) && o.push(i)
    }), t = o[gi.l] === 1 ? o[0] : o), t) : u || !r ? t : o
  }).globals = function () {
    Y(); const n = xi.extend(!0, {}, z); return delete n.msie, n
  }, _i.defaultOptions = function (n) {
    Y(); const t = z.defaultOptions; if (n === bi) {
      return xi.extend(!0, {}, t)
    } z.defaultOptions = xi.extend(!0, {}, t, Oi._(n, Oi.m, !0, t).O)
  }, _i.valid = function (n) {
    return n instanceof _i && !n.getState().destroyed
  }, _i.extension = function (n, t, r) {
    const e = mi.type(n) == _t; const i = arguments[gi.l]; let o = 0; if (i < 1 || !e) {
      return xi.extend(!0, {
        length:q[gi.l]
      }, q)
    } if (e) {
      if (mi.type(t) == yt) {
        q.push({
          name:n,
          extensionFactory:t,
          defaultOptions:r
        })
      } else {
        for (;o < q[gi.l]; o++) {
          if (q[o].name === n) {
            if (!(i > 1)) {
              return xi.extend(!0, {}, q[o]) 
} q.splice(o, 1)
          }
        }
      }
    }
  }, _i); function Y() {
    z = z || new $(Oi.g), k = k || new G(z)
  } function $(n) {
    const _ = this; const i = 'overflow'; const O = xi('body'); const S = xi('<div id="os-dummy-scrollbar-size"><div></div></div>'); const o = S[0]; const e = xi(S.children('div').eq(0)); O.append(S), S.hide().show(); let t; let r; let u; let f; let a; let c; let s; let l; let v; const h = z(o); const d = {
      x:h.x === 0,
      y:h.y === 0
    }; const p = (r = gt.navigator.userAgent, f = 'substring', a = r[u = 'indexOf']('MSIE '), c = r[u]('Trident/'), s = r[u]('Edge/'), l = r[u]('rv:'), v = parseInt, a > 0 ? t = v(r[f](a + 5, r[u]('.', a)), 10) : c > 0 ? t = v(r[f](l + 3, r[u]('.', l)), 10) : s > 0 && (t = v(r[f](s + 5, r[u]('.', s)), 10)), t); function z(n) {
      return {
        x:n[gi.oH] - n[gi.cH],
        y:n[gi.oW] - n[gi.cW]
      }
    }xi.extend(_, {
      defaultOptions:n,
      msie:p,
      autoUpdateLoop:!1,
      autoUpdateRecommended:!mi.mO(),
      nativeScrollbarSize:h,
      nativeScrollbarIsOverlaid:d,
      nativeScrollbarStyling:(function () {
        let n = !1; S.addClass('os-viewport-native-scrollbars-invisible'); try {
          n = S.css('scrollbar-width') === 'none' && (p > 9 || !p) || gt.getComputedStyle(o, '::-webkit-scrollbar').getPropertyValue('display') === 'none'
        } catch (t) {} return n
      }()),
      overlayScrollbarDummySize:{
        x:30,
        y:30
      },
      cssCalc:(function () {
        for (var n, t = mt.createElement('div')[gi.s], r = -1; r < zt.e[gi.l]; r++) {
          if (n = r < 0 ? 'calc' : `${zt.e[r]}calc`, t.cssText = `width:${n}(1px);`, t[gi.l]) {
            return n
          }
        } return null
      }()),
      restrictedMeasuring:(function () {
        S.css(i, 'hidden'); const n = o[gi.sW]; const t = o[gi.sH]; S.css(i, 'visible'); const r = o[gi.sW]; const e = o[gi.sH]; return n - r != 0 || t - e != 0
      }()),
      rtlScrollBehavior:(function () {
        S.css({
          'overflow-y':'hidden',
          'overflow-x':'scroll',
          direction:'rtl'
        }).scrollLeft(0); const n = S.offset(); const t = e.offset(); S.scrollLeft(-999); const r = e.offset(); return {
          i:n.left === t.left,
          n:t.left !== r.left
        }
      }()),
      supportTransform:zt.v('transform') !== bi,
      supportTransition:zt.v('transition') !== bi,
      supportPassiveEvents:(function () {
        let n = !1; try {
          gt.addEventListener('test', null, Object.defineProperty({}, 'passive', {
            get() {
              n = !0
            }
          }))
        } catch (t) {} return n
      }()),
      supportResizeObserver:Boolean(mi.rO()),
      supportMutationObserver:Boolean(mi.mO())
    }), S.removeAttr(gi.s).remove(), (function () {
      if (!d.x || !d.y) {
        const g = wi.abs; let m = mi.wW(); let w = mi.wH(); let y = x(); xi(gt).on('resize', () => {
          if (Si().length > 0) {
            const n = mi.wW(); const t = mi.wH(); const r = n - m; const e = t - w; if (r == 0 && e == 0) {
              return
            } let i; const o = wi.round(n / (m / 100)); const u = wi.round(t / (w / 100)); const f = g(r); const a = g(e); const c = g(o); const s = g(u); const l = x(); const v = f > 2 && a > 2; const h = !(function b(n, t) {
              const r = g(n); const e = g(t); return r !== e && r + 1 !== e && r - 1 !== e
            }(c, s)); const d = v && h && (l !== y && y > 0); const p = _.nativeScrollbarSize; d && (O.append(S), i = _.nativeScrollbarSize = z(S[0]), S.remove(), p.x === i.x && p.y === i.y || xi.each(Si(), function () {
              Si(this) && Si(this).update('zoom')
            })), m = n, w = t, y = l
          }
        })
      } function x() {
        const n = gt.screen.deviceXDPI || 0; const t = gt.screen.logicalXDPI || 1; return gt.devicePixelRatio || n / t
      }
    }())
  } function G(r) {
    let c; const e = xi.inArray; const s = mi.now; const l = 'autoUpdate'; const v = gi.l; const h = []; const d = []; let p = !1; let b = 33; let g = s(); var m = function () {
      if (h[v] > 0 && p) {
        c = mi.rAF()(() => {
          m()
        }); let n; let t; let r; let e; let i; let o; const u = s(); const f = u - g; if (b < f) {
          g = u - f % b, n = 33; for (let a = 0; a < h[v]; a++) {
            (t = h[a]) !== bi && (e = (r = t.options())[l], i = wi.max(1, r.autoUpdateInterval), o = s(), (!0 === e || e === null) && o - d[a] > i && (t.update('auto'), d[a] = new Date(o += i)), n = wi.max(1, wi.min(n, i)))
          }b = n
        }
      } else {
        b = 33
      }
    }; this.add = function (n) {
      e(n, h) === -1 && (h.push(n), d.push(s()), h[v] > 0 && !p && (p = !0, r.autoUpdateLoop = p, m()))
    }, this.remove = function (n) {
      const t = e(n, h); t > -1 && (d.splice(t, 1), h.splice(t, 1), h[v] === 0 && p && (p = !1, r.autoUpdateLoop = p, c !== bi && (mi.cAF()(c), c = -1)))
    }
  } function K(r, n, t, kt, Ct) {
    const cn = mi.type; const sn = xi.inArray; const c = xi.each; const It = new _i(); const e = xi[gi.p]; if (st(r)) {
      if (Si(r)) {
        const i = Si(r); return i.options(n), i
      } var Tt; var At; var Ht; var Et; var R; var Lt; var Nt; var Rt; var W; var ln; var m; var T; var l; var Wt; var Dt; var Mt; var Ft; var w; var v; var jt; var Pt; var Bt; var Qt; var Ut; var Vt; var qt; var Xt; var Yt; var $t; let o; var u; var Gt; var Kt; var Jt; let f; var D; var h; var M; var Zt; var nr; var tr; var rr; var er; var ir; var or; var ur; var fr; var ar; var cr; var a; var s; var d; var p; var b; var g; var y; var A; var sr; var lr; var vr; var H; var hr; var dr; var pr; var br; var gr; var mr; var wr; var yr; var xr; var _r; var Or; var Sr; var zr; var kr; var Cr; var Ir; var E; var Tr; var Ar; var Hr; var Er; var Lr; var Nr; var Rr; var Wr; let x; var _; var Dr; var Mr; var Fr; var jr; var Pr; var Br; var Qr; var Ur; var Vr; var qr; var Xr; var Yr; var $r; var Gr; var Kr; var O; var S; var z; var k; var Jr; var Zr; var C; var I; var ne; var te; var re; var ee; var ie; var F; var j; var oe; var ue; var fe; var ae; var ce = {}; var vn = {}; var hn = {}; var se = {}; var le = {}; const L = '-hidden'; var ve = 'margin-'; var he = 'padding-'; var de = 'border-'; var pe = 'top'; var be = 'right'; var ge = 'bottom'; var me = 'left'; var we = 'min-'; var ye = 'max-'; var xe = 'width'; var _e = 'height'; var Oe = 'float'; var Se = ''; var ze = 'auto'; const dn = 'sync'; var ke = 'scroll'; var Ce = '100%'; var pn = 'x'; var bn = 'y'; var N = '.'; var Ie = ' '; const P = 'scrollbar'; const B = '-horizontal'; const Q = '-vertical'; var Te = `${ke}Left`; var Ae = `${ke}Top`; var U = 'mousedown touchstart'; var V = 'mouseup touchend touchcancel'; var q = 'mousemove touchmove'; var X = 'mouseenter'; var Y = 'mouseleave'; var $ = 'keydown'; var G = 'keyup'; var K = 'selectstart'; var J = 'transitionend webkitTransitionEnd oTransitionEnd'; var Z = '__overlayScrollbarsRO__'; const nn = 'os-'; var tn = 'os-html'; var rn = 'os-host'; var en = `${rn}-textarea`; var on = `${rn}-${P}${B}${L}`; var un = `${rn}-${P}${Q}${L}`; var fn = `${rn}-transition`; var He = `${rn}-rtl`; var Ee = `${rn}-resize-disabled`; var Le = `${rn}-scrolling`; var Ne = `${rn}-overflow`; var Re = `${Ne}-x`; var We = `${Ne}-y`; var an = 'os-textarea'; var gn = `${an}-cover`; var mn = 'os-padding'; var wn = 'os-viewport'; var De = `${wn}-native-scrollbars-invisible`; var yn = `${wn}-native-scrollbars-overlaid`; var xn = 'os-content'; var Me = 'os-content-arrange'; var Fe = 'os-content-glue'; var je = 'os-size-auto-observer'; var _n = 'os-resize-observer'; var On = 'os-resize-observer-item'; var Sn = `${On}-final`; var zn = 'os-text-inherit'; var kn = nn + P; var Cn = `${kn}-track`; var In = `${Cn}-off`; var Tn = `${kn}-handle`; var An = `${Tn}-off`; var Hn = `${kn}-unusable`; var En = `${kn}-${ze}${L}`; var Ln = `${kn}-corner`; var Pe = `${Ln}-resize`; var Be = `${Pe}-both`; var Qe = Pe + B; var Ue = Pe + Q; var Nn = kn + B; var Rn = kn + Q; var Wn = 'os-dragging'; var Ve = 'os-theme-none'; var Dn = [De, yn, In, An, Hn, En, Pe, Be, Qe, Ue, Wn].join(Ie); var Mn = []; var Fn = [gi.ti]; var jn = {}; var qe = {}; var Xe = 42; let Pn = []; const Bn = {}; var Qn = ['wrap', 'cols', 'rows']; var Un = [gi.i, gi.c, gi.s, 'open'].concat(Fn); var Vn = []; return It.sleep = function () {
        $t = !0
      }, It.update = function (n) {
        if (!Dt) {
          let t; let r; let e; let i; let o; const u = cn(n) == _t; return u ? n === ze ? (t = (function f() {
            if (!$t && !Jr) {
              let r; let e; let i; const o = []; const n = [{
                z:nr,
                k:Un.concat(':visible')
              }, {
                z:Mt ? Zt : bi,
                k:Qn
              }]; return c(n, (n, t) => {
                (r = t.z) && c(t.k, (n, t) => {
                  e = t.charAt(0) === ':' ? r.is(t) : r.attr(t), i = Bn[t], vi(e, i) && o.push(t), Bn[t] = e
                })
              }), rt(o), o[gi.l] > 0
            }
          }()), r = (function a() {
            if ($t) {
              return !1
            } let n; let t; let r; let e; const i = si(); const o = Mt && xr && !Vr ? Zt.val().length : 0; const u = !Jr && xr && !Mt; const f = {}; return u && (n = or.css(Oe), f[Oe] = Yt ? be : me, f[xe] = ze, or.css(f)), e = {
              w:i[gi.sW] + o,
              h:i[gi.sH] + o
            }, u && (f[Oe] = n, f[xe] = Ce, or.css(f)), t = Je(), r = vi(e, x), x = e, r || t
          }()), (e = t || r) && ni({
            C:r,
            I:Wt ? bi : Gt
          })) : n === dn ? Jr ? (i = z(O.takeRecords()), o = k(S.takeRecords())) : i = It.update(ze) : n === 'zoom' && ni({
            T:!0,
            C:!0
          }) : (n = $t || n, $t = !1, It.update(dn) && !n || ni({
            A:n
          })), Mt || or.find('img').each((n, t) => {
            mi.inA(t, Pn) === -1 && xi(t).off('load', nt).on('load', nt)
          }), e || i || o
        }
      }, It.options = function (n, t) {
        let r; const e = {}; if (xi.isEmptyObject(n) || !xi.isPlainObject(n)) {
          if (cn(n) != _t) {
            return u
          } if (!(arguments.length > 1)) {
            return ht(u, n)
          } !(function a(n, t, r) {
            for (var e = t.split(N), i = e.length, o = 0, u = {}, f = u; o < i; o++) {
              u = u[e[o]] = o + 1 < i ? {} : r
            }xi.extend(n, f, !0)
          }(e, n, t)), r = et(e)
        } else {
          r = et(n)
        }xi.isEmptyObject(r) || ni({
          I:r
        })
      }, It.destroy = function () {
        if (!Dt) {
          for (const n in Ct.remove(It), Ge(), Ye(rr), Ye(tr), jn) {
            It.removeExt(n)
          } for (;Vn[gi.l] > 0;) {
            Vn.pop()()
          }Ke(!0), fr && dt(fr), ur && dt(ur), Pt && dt(tr), ut(!0), at(!0), it(!0); for (let t = 0; t < Pn[gi.l]; t++) {
            xi(Pn[t]).off('load', nt)
          }Pn = bi, $t = Dt = !0, Si(r, 0), fi('onDestroyed')
        }
      }, It.scroll = function (n, t, r, e) {
        if (arguments.length === 0 || n === bi) {
          const i = Br && Yt && Ht.i; const o = Br && Yt && Ht.n; let u = vn.H; let f = vn.L; let a = vn.N; return f = i ? 1 - f : f, u = i ? a - u : u, a *= o ? -1 : 1, {
            position:{
              x:u *= o ? -1 : 1,
              y:hn.H
            },
            ratio:{
              x:f,
              y:hn.L
            },
            max:{
              x:a,
              y:hn.N
            },
            handleOffset:{
              x:vn.R,
              y:hn.R
            },
            handleLength:{
              x:vn.W,
              y:hn.W
            },
            handleLengthRatio:{
              x:vn.D,
              y:hn.D
            },
            trackLength:{
              x:vn.M,
              y:hn.M
            },
            snappedHandleOffset:{
              x:vn.F,
              y:hn.F
            },
            isRTL:Yt,
            isRTLNormalized:Br
          }
        }It.update(dn); let c; let s; let l; let v; let h; let m; let w; let d; let p; const y = Br; const b = [pn, me, 'l']; const g = [bn, pe, 't']; const x = ['+=', '-=', '*=', '/=']; const _ = cn(t) == wt; const O = _ ? t.complete : e; const S = {}; const z = {}; const k = 'begin'; const C = 'nearest'; const I = 'never'; const T = 'ifneeded'; const A = gi.l; const H = [pn, bn, 'xy', 'yx']; const E = [k, 'end', 'center', C]; const L = ['always', I, T]; const N = n[gi.hOP]('el'); const R = N ? n.el : n; const W = Boolean(R instanceof xi || yi) && R instanceof yi; const D = !W && st(R); const M = function () {
          s && ii(!0), l && ii(!1)
        }; const F = cn(O) != yt ? bi : function () {
          M(), O()
        }; function j(n, t) {
          for (c = 0; c < t[A]; c++) {
            if (n === t[c]) {
              return 1
            }
          }
        } function P(n, t) {
          const r = n ? b : g; if (t = cn(t) == _t || cn(t) == St ? [t, t] : t, cn(t) == xt) {
            return n ? t[0] : t[1]
          } if (cn(t) == wt) {
            for (c = 0; c < r[A]; c++) {
              if (r[c] in t) {
                return t[r[c]]
              }
            }
          }
        } function B(n, t) {
          let r; let e; let i; let o; const u = cn(t) == _t; const f = n ? vn : hn; const a = f.H; const c = f.N; const s = Yt && n; const l = s && Ht.n && !y; const v = 'replace'; const h = eval; if ((e = u ? (t[A] > 2 && (o = t.substr(0, 2), sn(o, x) > -1 && (r = o)), t = (t = r ? t.substr(2) : t)[v](/min/g, 0)[v](/</g, 0)[v](/max/g, (l ? '-' : Se) + Ce)[v](/>/g, (l ? '-' : Se) + Ce)[v](/px/g, Se)
            [v](/%/g, ` * ${c * (s && Ht.n ? -1 : 1) / 100}`)
            [v](/vw/g, ` * ${se.w}`)
            [v](/vh/g, ` * ${se.h}`), ci(isNaN(t) ? ci(h(t), !0).toFixed() : t)) : t) !== bi && !isNaN(e) && cn(e) == St) {
            const d = y && s; let p = a * (d && Ht.n ? -1 : 1); const b = d && Ht.i; const g = d && Ht.n; switch (p = b ? c - p : p, r) {
              case '+=':i = p + e; break; case '-=':i = p - e; break; case '*=':i = p * e; break; case '/=':i = p / e; break; default:i = e
            }i = b ? c - i : i, i *= g ? -1 : 1, i = s && Ht.n ? wi.min(0, wi.max(c, i)) : wi.max(0, wi.min(c, i))
          } return i === a ? bi : i
        } function Q(n, t, r, e) {
          let i; let o; const u = [r, r]; const f = cn(n); if (f == t) {
            n = [n, n]
          } else if (f == xt) {
            if ((i = n[A]) > 2 || i < 1) {
              n = u
            } else {
              for (i === 1 && (n[1] = r), c = 0; c < i; c++) {
                if (o = n[c], cn(o) != t || !j(o, e)) {
                  n = u; break
                }
              }
            }
          } else {
            n = f == wt ? [n[pn] || r, n[bn] || r] : u
          } return {
            x:n[0],
            y:n[1]
          }
        } function U(n) {
          let t; let r; const e = []; const i = [pe, be, ge, me]; for (c = 0; c < n[A] && c !== i[A]; c++) {
            t = n[c], (r = cn(t)) == Ot ? e.push(t ? ci(p.css(ve + i[c])) : 0) : e.push(r == St ? t : 0)
          } return e
        } if (W || D) {
          let V; let q = N ? n.margin : 0; const X = N ? n.axis : 0; const Y = N ? n.scroll : 0; const $ = N ? n.block : 0; const G = [0, 0, 0, 0]; const K = cn(q); if ((p = W ? R : xi(R))[A] > 0) {
            q = K == St || K == Ot ? U([q, q, q, q]) : K == xt ? (V = q[A]) === 2 ? U([q[0], q[1], q[0], q[1]]) : V >= 4 ? U(q) : G : K == wt ? U([q[pe], q[be], q[ge], q[me]]) : G, h = j(X, H) ? X : 'xy', m = Q(Y, _t, 'always', L), w = Q($, _t, k, E), d = q; const J = vn.H; const Z = hn.H; const nn = er.offset(); const tn = p.offset(); const rn = {
              x:m.x == I || h == bn,
              y:m.y == I || h == pn
            }; tn[pe] -= d[0], tn[me] -= d[3]; const en = {
              x:wi.round(tn[me] - nn[me] + J),
              y:wi.round(tn[pe] - nn[pe] + Z)
            }; if (Yt && (Ht.n || Ht.i || (en.x = wi.round(nn[me] - tn[me] + J)), Ht.n && y && (en.x *= -1), Ht.i && y && (en.x = wi.round(nn[me] - tn[me] + (vn.N - J)))), w.x != k || w.y != k || m.x == T || m.y == T || Yt) {
              const on = p[0]; const un = ln ? on[gi.bCR]() : {
                width:on[gi.oW],
                height:on[gi.oH]
              }; const fn = {
                w:un[xe] + d[3] + d[1],
                h:un[_e] + d[0] + d[2]
              }; const an = function (n) {
                const t = ui(n); const r = t.j; const e = t.P; const i = t.B; let o = w[i] == (n && Yt ? k : 'end'); const u = w[i] == 'center'; const f = w[i] == C; const a = m[i] == I; const c = m[i] == T; const s = se[r]; const l = nn[e]; const v = fn[r]; const h = tn[e]; const d = u ? 2 : 1; const p = h + v / 2; const b = l + s / 2; const g = v <= s && l <= h && h + v <= l + s; a ? rn[i] = !0 : rn[i] || ((f || c) && (rn[i] = c && g, o = v < s ? b < p : p < b), en[i] -= o || u ? (s / d - v / d) * (n && Yt && y ? -1 : 1) : 0)
              }; an(!0), an(!1)
            }rn.y && delete en.y, rn.x && delete en.x, n = en
          }
        }S[Te] = B(!0, P(!0, n)), S[Ae] = B(!1, P(!1, n)), s = S[Te] !== bi, l = S[Ae] !== bi, (s || l) && (t > 0 || _) ? _ ? (t.complete = F, ir.animate(S, t)) : (v = {
          duration:t,
          complete:F
        }, cn(r) == xt || xi.isPlainObject(r) ? (z[Te] = r[0] || r.x, z[Ae] = r[1] || r.y, v.specialEasing = z) : v.easing = r, ir.animate(S, v)) : (s && ir[Te](S[Te]), l && ir[Ae](S[Ae]), M())
      }, It.scrollStop = function (n, t, r) {
        return ir.stop(n, t, r), It
      }, It.getElements = function (n) {
        const t = {
          target:sr,
          host:lr,
          padding:hr,
          viewport:dr,
          content:pr,
          scrollbarHorizontal:{
            scrollbar:a[0],
            track:s[0],
            handle:d[0]
          },
          scrollbarVertical:{
            scrollbar:p[0],
            track:b[0],
            handle:g[0]
          },
          scrollbarCorner:cr[0]
        }; return cn(n) == _t ? ht(t, n) : t
      }, It.getState = function (n) {
        function t(n) {
          if (!xi.isPlainObject(n)) {
            return n
          } const r = hi({}, n); const t = function (n, t) {
            r[gi.hOP](n) && (r[t] = r[n], delete r[n])
          }; return t('w', xe), t('h', _e), delete r.c, r
        } const r = {
          destroyed:Boolean(t(Dt)),
          sleeping:Boolean(t($t)),
          autoUpdate:t(!Jr),
          widthAuto:t(xr),
          heightAuto:t(_r),
          padding:t(zr),
          overflowAmount:t(Lr),
          hideOverflow:t(yr),
          hasOverflow:t(wr),
          contentScrollSize:t(gr),
          viewportSize:t(se),
          hostSize:t(br),
          documentMixed:t(w)
        }; return cn(n) == _t ? ht(r, n) : r
      }, It.ext = function (n) {
        let t; const r = 'added removed on contract'.split(' '); let e = 0; if (cn(n) == _t) {
          if (jn[gi.hOP](n)) {
            for (t = hi({}, jn[n]); e < r.length; e++) {
              delete t[r[e]]
            }
          }
        } else {
          for (e in t = {}, jn) {
            t[e] = hi({}, It.ext(e))
          }
        } return t
      }, It.addExt = function (n, t) {
        let r; let e; let i; let o; const u = _i.extension(n); let f = !0; if (u) {
          if (jn[gi.hOP](n)) {
            return It.ext(n)
          } if ((r = u.extensionFactory.call(It, hi({}, u.defaultOptions), xi, mi)) && (i = r.contract, cn(i) == yt && (o = i(gt), f = cn(o) == Ot ? o : f), f)) {
            return e = (jn[n] = r).added, cn(e) == yt && e(t), It.ext(n)
          }
        } else {
          console.warn(`A extension with the name "${n}" isn't registered.`)
        }
      }, It.removeExt = function (n) {
        let t; const r = jn[n]; return Boolean(r) && (delete jn[n], t = r.removed, cn(t) == yt && t(), !0)
      }, _i.valid(function bt(n, t, r) {
        let e; let i; return o = kt.defaultOptions, Lt = kt.nativeScrollbarStyling, Rt = hi({}, kt.nativeScrollbarSize), Tt = hi({}, kt.nativeScrollbarIsOverlaid), At = hi({}, kt.overlayScrollbarDummySize), Ht = hi({}, kt.rtlScrollBehavior), et(hi({}, o, t)), Nt = kt.cssCalc, R = kt.msie, Et = kt.autoUpdateRecommended, W = kt.supportTransition, ln = kt.supportTransform, m = kt.supportPassiveEvents, T = kt.supportResizeObserver, l = kt.supportMutationObserver, kt.restrictedMeasuring, D = xi(n.ownerDocument), A = D[0], f = xi(A.defaultView || A.parentWindow), y = f[0], h = pt(D, 'html'), M = pt(h, 'body'), Zt = xi(n), sr = Zt[0], Mt = Zt.is('textarea'), Ft = Zt.is('body'), w = A !== mt, v = Mt ? Zt.hasClass(an) && Zt.parent().hasClass(xn) : Zt.hasClass(rn) && Zt.children(N + mn)[gi.l], Tt.x && Tt.y && !Gt.nativeScrollbarsOverlaid.initialize ? (fi('onInitializationWithdrawn'), v && (it(!0), ut(!0), at(!0)), $t = Dt = !0) : (Ft && ((e = {}).l = wi.max(Zt[Te](), h[Te](), f[Te]()), e.t = wi.max(Zt[Ae](), h[Ae](), f[Ae]()), i = function () {
          ir.removeAttr(gi.ti), qn(ir, U, i, !0, !0)
        }), it(), ut(), at(), ot(), ft(!0), ft(!1), (function s() {
          let r; const t = y.top !== y; let e = {}; const i = {}; let o = {}; function u(n) {
            if (a(n)) {
              const t = c(n); const r = {}; (fe || ue) && (r[xe] = i.w + (t.x - e.x) * o.x), (ae || ue) && (r[_e] = i.h + (t.y - e.y) * o.y), nr.css(r), mi.stpP(n)
            } else {
              f(n)
            }
          } function f(n) {
            const t = n !== bi; qn(D, [K, q, V], [Zn, u, f], !0), pi(M, Wn), cr.releaseCapture && cr.releaseCapture(), t && (r && $e(), It.update(ze)), r = !1
          } function a(n) {
            const t = (n.originalEvent || n).touches !== bi; return !$t && !Dt && (mi.mBtn(n) === 1 || t)
          } function c(n) {
            return R && t ? {
              x:n.screenX,
              y:n.screenY
            } : mi.page(n)
          }Xn(cr, U, (n) => {
            a(n) && !oe && (Jr && (r = !0, Ge()), e = c(n), i.w = lr[gi.oW] - (jt ? 0 : Bt), i.h = lr[gi.oH] - (jt ? 0 : Qt), o = ct(), qn(D, [K, q, V], [Zn, u, f]), di(M, Wn), cr.setCapture && cr.setCapture(), mi.prvD(n), mi.stpP(n))
          })
        }()), Yn(), Ye(rr, $n), Ft && (ir[Te](e.l)[Ae](e.t), mt.activeElement == n && dr.focus && (ir.attr(gi.ti, '-1'), dr.focus(), qn(ir, U, i, !1, !0))), It.update(ze), Wt = !0, fi('onInitialized'), c(Mn, (n, t) => {
          fi(t.n, t.a)
        }), Mn = [], cn(r) == _t && (r = [r]), mi.isA(r) ? c(r, (n, t) => {
          It.addExt(t)
        }) : xi.isPlainObject(r) && c(r, (n, t) => {
          It.addExt(n, t)
        }), setTimeout(() => {
          W && !Dt && di(nr, fn)
        }, 333)), It
      }(r, n, t)) && Si(r, It), It
    } function qn(n, t, r, e, i) {
      const o = cn(t) == xt && cn(r) == xt; const u = e ? 'removeEventListener' : 'addEventListener'; const f = e ? 'off' : 'on'; const a = !o && t.split(Ie); let c = 0; if (o) {
        for (;c < t[gi.l]; c++) {
          qn(n, t[c], r[c], e)
        }
      } else {
        for (;c < a[gi.l]; c++) {
          m ? n[0][u](a[c], r, {
            passive:i || !1
          }) : n[f](a[c], r)
        }
      }
    } function Xn(n, t, r, e) {
      qn(n, t, r, !1, e), Vn.push(mi.bind(qn, 0, n, t, r, !0, e))
    } function Ye(n, t) {
      if (n) {
        const r = mi.rO(); const e = 'animationstart mozAnimationStart webkitAnimationStart MSAnimationStart'; const i = 'childNodes'; const o = 3333333; const u = function () {
          n[Ae](o)[Te](Yt ? Ht.n ? -o : Ht.i ? 0 : o : o), t()
        }; if (t) {
          if (T) {
            ((C = n.addClass('observed').append(li(_n)).contents()[0])[Z] = new r(u)).observe(C)
          } else if (R > 9 || !Et) {
            n.prepend(li(_n, li({
              c:On,
              dir:'ltr'
            }, li(On, li(Sn)) + li(On, li({
              c:Sn,
              style:'width: 200%; height: 200%'
            }))))); let f; let a; let c; let s; const l = n[0][i][0][i][0]; const v = xi(l[i][1]); const h = xi(l[i][0]); const d = xi(h[0][i][0]); let p = l[gi.oW]; let b = l[gi.oH]; const g = kt.nativeScrollbarSize; const m = function () {
              h[Te](o)[Ae](o), v[Te](o)[Ae](o)
            }; const w = function () {
              a = 0, f && (p = c, b = s, u())
            }; const y = function (n) {
              return c = l[gi.oW], s = l[gi.oH], f = c != p || s != b, n && f && !a ? (mi.cAF()(a), a = mi.rAF()(w)) : n || w(), m(), n && (mi.prvD(n), mi.stpP(n)), !1
            }; const x = {}; const _ = {}; ai(_, Se, [-2 * (g.y + 1), -2 * g.x, -2 * g.y, -2 * (g.x + 1)]), xi(l).css(_), h.on(ke, y), v.on(ke, y), n.on(e, () => {
              y(!1)
            }), x[xe] = o, x[_e] = o, d.css(x), m()
          } else {
            const O = A.attachEvent; const S = R !== bi; if (O) {
              n.prepend(li(_n)), pt(n, N + _n)[0].attachEvent('onresize', u)
            } else {
              const z = A.createElement(wt); z.setAttribute(gi.ti, '-1'), z.setAttribute(gi.c, _n), z.onload = function () {
                const n = this.contentDocument.defaultView; n.addEventListener('resize', u), n.document.documentElement.style.display = 'none'
              }, z.type = 'text/html', S && n.prepend(z), z.data = 'about:blank', S || n.prepend(z), n.on(e, u)
            }
          } if (n[0] === H) {
            const k = function () {
              const n = nr.css('direction'); const t = {}; let r = 0; let e = !1; return n !== E && (r = n === 'ltr' ? (t[me] = 0, t[be] = ze, o) : (t[me] = ze, t[be] = 0, Ht.n ? -o : Ht.i ? 0 : o), rr.children().eq(0).css(t), rr[Te](r)[Ae](o), E = n, e = !0), e
            }; k(), Xn(n, ke, (n) => (k() && ni(), mi.prvD(n), mi.stpP(n), !1))
          }
        } else if (T) {
          var C; const I = (C = n.contents()[0])[Z]; I && (I.disconnect(), delete C[Z])
        } else {
          dt(n.children(N + _n).eq(0))
        }
      }
    } function Yn() {
      if (l) {
        let i; let o; let r; let e; let u; let f; const n = mi.mO(); let a = mi.now(); k = function (n) {
          let t = !1; return Wt && !$t && (c(n, function () {
            return !(t = (function o(n) {
              const t = n.attributeName; const r = n.target; const e = n.type; const i = 'closest'; if (r === pr) {
                return t === null
              } if (e === 'attributes' && (t === gi.c || t === gi.s) && !Mt) {
                if (t === gi.c && xi(r).hasClass(rn)) {
                  return tt(n.oldValue, r.getAttribute(gi.c))
                } if (typeof r[i] !== yt) {
                  return !0
                } if (r[i](N + _n) !== null || r[i](N + kn) !== null || r[i](N + Ln) !== null) {
                  return !1
                }
              } return !0
            }(this)))
          }), t && (e = mi.now(), u = _r || xr, f = function () {
            Dt || (a = e, Mt && Ze(), u ? ni() : It.update(ze))
          }, clearTimeout(r), e - a > 11 || !u ? f() : r = setTimeout(f, 11))), t
        }, O = new n(z = function (n) {
          let t; let r = !1; const e = []; return Wt && !$t && (c(n, function () {
            i = (t = this).target, o = t.attributeName, r = r || (o === gi.c ? tt(t.oldValue, i.className) : o !== gi.s || t.oldValue !== i[gi.s].cssText), e.push(o)
          }), rt(e), r && It.update(ze)), r
        }), S = new n(k)
      }
    } function $e() {
      l && !Jr && (O.observe(lr, {
        attributes:!0,
        attributeOldValue:!0,
        attributeFilter:Un
      }), S.observe(Mt ? sr : pr, {
        attributes:!0,
        attributeOldValue:!0,
        subtree:!Mt,
        childList:!Mt,
        characterData:!Mt,
        attributeFilter:Mt ? Qn : Un
      }), Jr = !0)
    } function Ge() {
      l && Jr && (O.disconnect(), S.disconnect(), Jr = !1)
    } function $n() {
      if (!$t) {
        let n; const t = {
          w:H[gi.sW],
          h:H[gi.sH]
        }; n = vi(t, _), _ = t, n && ni({
          T:!0
        })
      }
    } function Gn() {
      ie && ri(!0)
    } function Kn() {
      ie && !M.hasClass(Wn) && ri(!1)
    } function Jn() {
      ee && (ri(!0), clearTimeout(I), I = setTimeout(() => {
        ee && !Dt && ri(!1)
      }, 100))
    } function Zn(n) {
      return mi.prvD(n), !1
    } function nt() {
      ni({
        C:!0
      })
    } function Ke(n) {
      qn(nr, q, Jn, !ee || n, !0), qn(nr, [X, Y], [Gn, Kn], Boolean(ee) || n, !0), Wt || n || nr.one('mouseover', Gn)
    } function Je() {
      const n = {}; return Ft && ur && (n.w = ci(ur.css(we + xe)), n.h = ci(ur.css(we + _e)), n.c = vi(n, Gr), n.f = !0), Boolean((Gr = n).c)
    } function tt(n, t) {
      const r = t !== bi && t !== null ? t.split(Ie) : Se; const e = n !== bi && n !== null ? n.split(Ie) : Se; if (r === Se && e === Se) {
        return !1
      } let i; let o; let u; let f; let a; const c = (function d(n, t) {
        let r; let e; const i = []; const o = []; for (r = 0; r < n.length; r++) {
          i[n[r]] = !0
        } for (r = 0; r < t.length; r++) {
          i[t[r]] ? delete i[t[r]] : i[t[r]] = !0
        } for (e in i) {
          o.push(e)
        } return o
      }(e, r)); let s = !1; const l = Ur !== bi && Ur !== null ? Ur.split(Ie) : [Se]; const v = Qr !== bi && Qr !== null ? Qr.split(Ie) : [Se]; const h = sn(Ve, c); for (h > -1 && c.splice(h, 1), o = 0; o < c.length; o++) {
        if ((i = c[o]).indexOf(rn) !== 0) {
          for (a = f = !0, u = 0; u < l.length; u++) {
            if (i === l[u]) {
              f = !1; break
            }
          } for (u = 0; u < v.length; u++) {
            if (i === v[u]) {
              a = !1; break
            }
          } if (f && a) {
            s = !0; break
          }
        }
      } return s
    } function rt(n) {
      c(n = n || Fn, (n, t) => {
        if (mi.inA(t, Fn) > -1) {
          const r = Zt.attr(t); cn(r) == _t ? ir.attr(t, r) : ir.removeAttr(t)
        }
      })
    } function Ze() {
      if (!$t) {
        let n; let t; let r; let e; const i = !Vr; const o = se.w; const u = se.h; const f = {}; const a = xr || i; return f[we + xe] = Se, f[we + _e] = Se, f[xe] = ze, Zt.css(f), n = sr[gi.oW], t = a ? wi.max(n, sr[gi.sW] - 1) : 1, f[xe] = xr ? ze : Ce, f[we + xe] = Ce, f[_e] = ze, Zt.css(f), r = sr[gi.oH], e = wi.max(r, sr[gi.sH] - 1), f[xe] = t, f[_e] = e, ar.css(f), f[we + xe] = o, f[we + _e] = u, Zt.css(f), {
          Q:n,
          U:r,
          V:t,
          X:e
        }
      }
    } function ni(n) {
      clearTimeout(Jt), n = n || {}, qe.T |= n.T, qe.C |= n.C, qe.A |= n.A; let t; const r = mi.now(); let e = Boolean(qe.T); let i = Boolean(qe.C); const o = Boolean(qe.A); const u = n.I; const f = Xe > 0 && Wt && !Dt && !o && !u && r - Kt < Xe && !_r && !xr; if (f && (Jt = setTimeout(ni, Xe)), !(Dt || f || $t && !u || Wt && !o && (t = nr.is(':hidden')) || nr.css('display') === 'inline')) {
        Kt = r, qe = {}, !Lt || Tt.x && Tt.y ? Rt = hi({}, kt.nativeScrollbarSize) : (Rt.x = 0, Rt.y = 0), le = {
          x:3 * (Rt.x + (Tt.x ? 0 : 3)),
          y:3 * (Rt.y + (Tt.y ? 0 : 3))
        }; const a = function () {
          return vi.apply(this, [].slice.call(arguments).concat([o]))
        }; const c = {
          x:ir[Te](),
          y:ir[Ae]()
        }; const s = Gt.scrollbars; const l = Gt.textarea; const v = s.visibility; const h = a(v, Dr); const d = s.autoHide; const p = a(d, Mr); const b = s.clickScrolling; const g = a(b, Fr); const m = s.dragScrolling; const w = a(m, jr); const y = Gt.className; const x = a(y, Qr); const _ = Gt.resize; const O = a(_, Pr) && !Ft; const S = Gt.paddingAbsolute; const z = a(S, Tr); const k = Gt.clipAlways; const C = a(k, Ar); const I = Gt.sizeAutoCapable && !Ft; const T = a(I, Wr); let A = Gt.nativeScrollbarsOverlaid.showNativeScrollbars; const H = a(A, Nr); const E = Gt.autoUpdate; const L = a(E, Rr); const N = Gt.overflowBehavior; const R = a(N, Er, o); const W = l.dynWidth; const D = a($r, W); const M = l.dynHeight; const F = a(Yr, M); if (te = d === 'n', re = d === 's', ee = d === 'm', ie = d === 'l', ne = s.autoHideDelay, Ur = Qr, oe = _ === 'n', ue = _ === 'b', fe = _ === 'h', ae = _ === 'v', Br = Gt.normalizeRTL, A = A && Tt.x && Tt.y, Dr = v, Mr = d, Fr = b, jr = m, Qr = y, Pr = _, Tr = S, Ar = k, Wr = I, Nr = A, Rr = E, Er = hi({}, N), $r = W, Yr = M, wr = wr || {
          x:!1,
          y:!1
        }, x && (pi(nr, Ur + Ie + Ve), di(nr, y !== bi && y !== null && y.length > 0 ? y : Ve)), L && (!0 === E || E === null && Et ? (Ge(), Ct.add(It)) : (Ct.remove(It), $e())), T) {
          if (I) {
            if (fr ? fr.show() : (fr = xi(li(Fe)), er.before(fr)), Pt) {
              tr.show()
            } else {
              tr = xi(li(je)), vr = tr[0], fr.before(tr); let j = {
                w:-1,
                h:-1
              }; Ye(tr, () => {
                const n = {
                  w:vr[gi.oW],
                  h:vr[gi.oH]
                }; vi(n, j) && (Wt && _r && n.h > 0 || xr && n.w > 0 || Wt && !_r && n.h === 0 || !xr && n.w === 0) && ni(), j = n
              }), Pt = !0, Nt !== null && tr.css(_e, `${Nt}(100% + 1px)`)
            }
          } else {
            Pt && tr.hide(), fr && fr.hide()
          }
        } o && (rr.find('*').trigger(ke), Pt && tr.find('*').trigger(ke)); a(t = t === bi ? nr.is(':hidden') : t, Kr); let P; const B = Boolean(Mt) && Zt.attr('wrap') !== 'off'; const Q = a(B, Vr); const U = nr.css('direction'); const V = a(U, Ir); const q = nr.css('box-sizing'); const X = a(q, Sr); const Y = {
          c:o,
          t:ci(nr.css(he + pe)),
          r:ci(nr.css(he + be)),
          b:ci(nr.css(he + ge)),
          l:ci(nr.css(he + me))
        }; try {
          P = Pt ? vr[gi.bCR]() : null
        } catch (St) {
          return
        }jt = q === 'border-box'; const $ = (Yt = U === 'rtl') ? me : be; const G = Yt ? be : me; let K = !1; const J = !(!Pt || nr.css(Oe) === 'none') && (wi.round(P.right - P.left) === 0 && (Boolean(S) || lr[gi.cW] - Bt > 0)); if (I && !J) {
          const Z = lr[gi.oW]; const nn = fr.css(xe); fr.css(xe, ze); let tn = lr[gi.oW]; fr.css(xe, nn), (K = Z !== tn) || (fr.css(xe, Z + 1), tn = lr[gi.oW], fr.css(xe, nn), K = Z !== tn)
        } const rn = (J || K) && I && !t; const en = a(rn, xr); const on = !rn && xr; const un = !(!Pt || !I || t) && wi.round(P.bottom - P.top) === 0; const fn = a(un, _r); const an = !un && _r; const cn = `-${xe}`; const sn = rn && jt || !jt; const ln = un && jt || !jt; const vn = {
          c:o,
          t:ln ? ci(nr.css(de + pe + cn), !0) : 0,
          r:sn ? ci(nr.css(de + be + cn), !0) : 0,
          b:ln ? ci(nr.css(de + ge + cn), !0) : 0,
          l:sn ? ci(nr.css(de + me + cn), !0) : 0
        }; const hn = {
          c:o,
          t:ci(nr.css(ve + pe)),
          r:ci(nr.css(ve + be)),
          b:ci(nr.css(ve + ge)),
          l:ci(nr.css(ve + me))
        }; const dn = {
          h:String(nr.css(ye + _e)),
          w:String(nr.css(ye + xe))
        }; let pn = {}; let bn = {}; const gn = function () {
          return {
            w:lr[gi.cW],
            h:lr[gi.cH]
          }
        }; const mn = function () {
          return {
            w:hr[gi.oW] + wi.max(0, pr[gi.cW] - pr[gi.sW]),
            h:hr[gi.oH] + wi.max(0, pr[gi.cH] - pr[gi.sH])
          }
        }; let wn = Bt = Y.l + Y.r; let yn = Qt = Y.t + Y.b; if (wn *= S ? 1 : 0, yn *= S ? 1 : 0, Y.c = a(Y, zr), Ut = vn.l + vn.r, Vt = vn.t + vn.b, vn.c = a(vn, kr), qt = hn.l + hn.r, Xt = hn.t + hn.b, hn.c = a(hn, Cr), dn.ih = ci(dn.h), dn.iw = ci(dn.w), dn.ch = dn.h.indexOf('px') > -1, dn.cw = dn.w.indexOf('px') > -1, dn.c = a(dn, Or), Kr = t, Vr = B, Ir = U, Sr = q, xr = rn, _r = un, zr = Y, kr = vn, Cr = hn, Or = dn, V && Pt && tr.css(Oe, G), Y.c || V || z || en || fn || X || T) {
          var xn = {}; const _n = {}; ai(bn, ve, [-Y.t, -Y.r, -Y.b, -Y.l]), S ? (ai(xn, Se, [Y.t, Y.r, Y.b, Y.l]), ai(Mt ? _n : pn, he)) : (ai(xn, Se), ai(Mt ? _n : pn, he, [Y.t, Y.r, Y.b, Y.l])), er.css(xn), Zt.css(_n)
        }se = mn(); const On = Boolean(Mt) && Ze(); const Sn = Mt && a(On, Xr); const zn = Mt && On ? {
          w:W ? On.V : On.Q,
          h:M ? On.X : On.U
        } : {}; if (Xr = On, un && (fn || z || X || dn.c || Y.c || vn.c) ? pn[_e] = ze : (fn || z) && (pn[ye + _e] = Se, pn[_e] = Ce), rn && (en || z || X || dn.c || Y.c || vn.c || V) ? (pn[xe] = ze, bn[ye + xe] = Ce) : (en || z) && (pn[ye + xe] = Se, pn[xe] = Ce, pn[Oe] = Se, bn[ye + xe] = Se), rn ? (dn.cw || (pn[ye + xe] = Se), bn[xe] = ze, pn[xe] = ze, pn[Oe] = G) : bn[xe] = Se, un ? (dn.ch || (pn[ye + _e] = Se), bn[_e] = zn.h || pr[gi.cH]) : bn[_e] = Se, I && fr.css(bn), or.css(pn), pn = {}, bn = {}, e || i || Sn || V || X || z || en || rn || fn || un || dn.c || H || R || C || O || h || p || w || g || D || F || Q) {
          const kn = 'overflow'; const Cn = `${kn}-x`; const In = `${kn}-y`; if (!Lt) {
            var Tn = {}; var An = wr.y && yr.ys && !A ? Tt.y ? ir.css($) : -Rt.y : 0; var Hn = wr.x && yr.xs && !A ? Tt.x ? ir.css(ge) : -Rt.x : 0; ai(Tn, Se), ir.css(Tn)
          } const En = si(); let Ln = {
            w:zn.w || En[gi.cW],
            h:zn.h || En[gi.cH]
          }; const Nn = En[gi.sW]; const Rn = En[gi.sH]; Lt || (Tn[ge] = an ? Se : Hn, Tn[$] = on ? Se : An, ir.css(Tn)), se = mn(); let Wn = gn(); const Dn = {
            w:wi.max((rn ? Ln.w : Nn) + wn, Wn.w),
            h:wi.max((un ? Ln.h : Rn) + yn, Wn.h)
          }; if (Dn.c = a(Dn, Hr), Hr = Dn, I) {
            (Dn.c || un || rn) && (bn[xe] = Dn.w, bn[_e] = Dn.h, Mt || (Ln = {
              w:En[gi.cW],
              h:En[gi.cH]
            })); const Mn = {}; const Fn = function (n) {
              const t = ui(n); const r = t.j; const e = t.Y; const i = n ? rn : un; const o = n ? Ut : Vt; const u = n ? Bt : Qt; const f = n ? qt : Xt; const a = bn[e] + (jt ? o : -u); i && (i || !vn.c) || (bn[e] = Wn[r] - (jt ? 0 : u + o) - 1 - f), i && dn[`c${r}`] && dn[`i${r}`] === a && (bn[e] = a + (jt ? 0 : u) + 1), !(i && Ln[r] < se[r]) || n && Mt && B || (Mt && (Mn[e] = ci(ar.css(e)) - 1), --bn[e]), Ln[r] > 0 && (bn[e] = wi.max(1, bn[e]))
            }; Fn(!0), Fn(!1), Mt && ar.css(Mn), fr.css(bn)
          }rn && (pn[xe] = Ce), !rn || jt || Jr || (pn[Oe] = 'none'), or.css(pn), pn = {}; const jn = {
            w:En[gi.sW],
            h:En[gi.sH]
          }; jn.c = i = a(jn, gr), gr = jn, se = mn(), e = a(Wn = gn(), br), br = Wn; const Pn = Mt && (se.w === 0 || se.h === 0); const Bn = Lr; const Qn = {}; const Un = {}; const Vn = {}; const qn = {}; const Xn = {}; const Yn = {}; const $n = {}; const Gn = hr[gi.bCR](); const Kn = function (n) {
            const t = ui(n); const r = ui(!n).B; const e = t.B; const i = t.j; const o = t.Y; const u = `${ke + t.$}Max`; const f = Gn[o] ? wi.abs(Gn[o] - se[i]) : 0; const a = Bn && Bn[e] > 0 && dr[u] === 0; Qn[e] = N[e] === 'v-s', Un[e] = N[e] === 'v-h', Vn[e] = N[e] === 's', qn[e] = wi.max(0, wi.round(100 * (jn[i] - se[i])) / 100), qn[e] *= Pn || a && f > 0 && f < 1 ? 0 : 1, Xn[e] = qn[e] > 0, Yn[e] = Qn[e] || Un[e] ? Xn[r] && !Qn[r] && !Un[r] : Xn[e], Yn[`${e}s`] = Boolean(Yn[e]) && (Vn[e] || Qn[e]), $n[e] = Xn[e] && Yn[`${e}s`]
          }; if (Kn(!0), Kn(!1), qn.c = a(qn, Lr), Lr = qn, Xn.c = a(Xn, wr), wr = Xn, Yn.c = a(Yn, yr), yr = Yn, Tt.x || Tt.y) {
            let Jn; const Zn = {}; const nt = {}; let tt = o; (Xn.x || Xn.y) && (nt.w = Tt.y && Xn.y ? jn.w + At.y : Se, nt.h = Tt.x && Xn.x ? jn.h + At.x : Se, tt = a(nt, mr), mr = nt), (Xn.c || Yn.c || jn.c || V || en || fn || rn || un || H) && (pn[ve + G] = pn[de + G] = Se, Jn = function (n) {
              const t = ui(n); const r = ui(!n); const e = t.B; const i = n ? ge : $; const o = n ? un : rn; Tt[e] && Xn[e] && Yn[`${e}s`] ? (pn[ve + i] = !o || A ? Se : At[e], pn[de + i] = n && o || A ? Se : `${At[e]}px solid transparent`) : (nt[r.j] = pn[ve + i] = pn[de + i] = Se, tt = !0)
            }, Lt ? (A ? pi : di)(ir, De) : (Jn(!0), Jn(!1))), A && (nt.w = nt.h = Se, tt = !0), tt && !Lt && (Zn[xe] = Yn.y ? nt.w : Se, Zn[_e] = Yn.x ? nt.h : Se, ur || (ur = xi(li(Me)), ir.prepend(ur)), ur.css(Zn)), or.css(pn)
          } let rt; let et = {}; xn = {}; if ((e || Xn.c || Yn.c || jn.c || R || X || H || V || C || fn) && (et[G] = Se, (rt = function (n) {
            const t = ui(n); const r = ui(!n); const e = t.B; const i = t.G; const o = n ? ge : $; const u = function () {
              et[o] = Se, ce[r.j] = 0
            }; Xn[e] && Yn[`${e}s`] ? (et[kn + i] = ke, A || Lt ? u() : (et[o] = -(Tt[e] ? At[e] : Rt[e]), ce[r.j] = Tt[e] ? At[r.B] : 0)) : (et[kn + i] = Se, u())
          })(!0), rt(!1), !Lt && (se.h < le.x || se.w < le.y) && (Xn.x && Yn.x && !Tt.x || Xn.y && Yn.y && !Tt.y) ? (et[he + pe] = le.x, et[ve + pe] = -le.x, et[he + G] = le.y, et[ve + G] = -le.y) : et[he + pe] = et[ve + pe] = et[he + G] = et[ve + G] = Se, et[he + $] = et[ve + $] = Se, Xn.x && Yn.x || Xn.y && Yn.y || Pn ? Mt && Pn && (xn[Cn] = xn[In] = 'hidden') : (!k || Un.x || Qn.x || Un.y || Qn.y) && (Mt && (xn[Cn] = xn[In] = Se), et[Cn] = et[In] = 'visible'), er.css(xn), ir.css(et), et = {}, (Xn.c || X || en || fn) && (!Tt.x || !Tt.y))) {
            const it = pr[gi.s]; it.webkitTransform = 'scale(1)', it.display = 'run-in', pr[gi.oH], it.display = Se, it.webkitTransform = Se
          } if (pn = {}, V || en || fn) {
            if (Yt && rn) {
              const ot = or.css(Oe); const ut = wi.round(or.css(Oe, Se).css(me, Se).position().left); or.css(Oe, ot), ut !== wi.round(or.position().left) && (pn[me] = ut)
            } else {
              pn[me] = Se
            }
          } if (or.css(pn), Mt && i) {
            const ft = (function zt() {
              const n = sr.selectionStart; if (n === bi) {
                return
              } let t; let r; const e = Zt.val(); const i = e[gi.l]; const o = e.split('\n'); const u = o[gi.l]; const f = e.substr(0, n).split('\n'); let a = 0; let c = 0; const s = f[gi.l]; const l = f[f[gi.l] - 1][gi.l]; for (r = 0; r < o[gi.l]; r++) {
                t = o[r][gi.l], c < t && (a = r + 1, c = t)
              } return {
                K:s,
                J:l,
                Z:u,
                nn:c,
                tn:a,
                rn:n,
                en:i
              }
            }()); if (ft) {
              const at = qr === bi || ft.Z !== qr.Z; const ct = ft.K; const st = ft.J; const lt = ft.tn; const vt = ft.Z; const ht = ft.nn; const dt = ft.rn; const pt = ft.en <= dt && Zr; const bt = {
                x:B || st !== ht || ct !== lt ? -1 : Lr.x,
                y:(B ? pt || at && Bn && c.y === Bn.y : (pt || at) && ct === vt) ? Lr.y : -1
              }; c.x = bt.x > -1 ? Yt && Br && Ht.i ? 0 : bt.x : c.x, c.y = bt.y > -1 ? bt.y : c.y
            }qr = ft
          }Yt && Ht.i && Tt.y && Xn.x && Br && (c.x += ce.w || 0), rn && nr[Te](0), un && nr[Ae](0), ir[Te](c.x)[Ae](c.y); const gt = v === 'v'; const mt = v === 'h'; const wt = v === 'a'; const yt = mi.bind(ti, 0, !0, !0, $n.x); const xt = mi.bind(ti, 0, !1, !0, $n.y); const _t = mi.bind(ti, 0, !0, !1, $n.x); const Ot = mi.bind(ti, 0, !1, !1, $n.y); (Yn.x || Yn.y ? di : pi)(nr, Ne), (Yn.x ? di : pi)(nr, Re), (Yn.y ? di : pi)(nr, We), V && (Yt ? di : pi)(nr, He), Ft && di(nr, Ee), O && (pi(cr, [Pe, Be, Qe, Ue].join(Ie)), oe ? di(nr, Ee) : (pi(nr, Ee), di(cr, Pe), ue ? di(cr, Be) : fe ? di(cr, Qe) : ae && di(cr, Ue))), (h || R || Yn.c || Xn.c || H) && (A ? H && (pi(nr, Le), A && (_t(), Ot())) : wt ? (($n.x ? yt : _t)(), ($n.y ? xt : Ot)()) : gt ? (yt(), xt()) : mt && (_t(), Ot())), (p || H) && (ie || ee ? (Ke(!0), Ke()) : Ke(!0), te ? ri(!0) : ri(!1, !0)), (e || qn.c || fn || en || O || X || z || H || V) && (ei(!0), ii(!0), ei(!1), ii(!1)), g && oi(!0, b), w && oi(!1, m), V && fi('onDirectionChanged', {
            isRTL:Yt,
            dir:U
          }), e && fi('onHostSizeChanged', {
            width:br.w,
            height:br.h
          }), i && fi('onContentSizeChanged', {
            width:gr.w,
            height:gr.h
          }), (Xn.c || Yn.c) && fi('onOverflowChanged', {
            x:Xn.x,
            y:Xn.y,
            xScrollable:Yn.xs,
            yScrollable:Yn.ys,
            clipped:Yn.x || Yn.y
          }), qn.c && fi('onOverflowAmountChanged', {
            x:qn.x,
            y:qn.y
          })
        }Ft && Gr && (wr.c || Gr.c) && (Gr.f || Je(), Tt.y && wr.x && or.css(we + xe, Gr.w + At.y), Tt.x && wr.y && or.css(we + _e, Gr.h + At.x), Gr.c = !1), fi('onUpdated', {
          forced:o
        })
      }
    } function et(n) {
      const t = Oi._(n, Oi.m, !0, u); return u = hi({}, u, t.O), Gt = hi({}, Gt, t.S), t.S
    } function it(e) {
      const n = 'parent'; const t = an + Ie + zn; const r = Mt ? Ie + zn : Se; let i = Gt.textarea.inheritedAttrs; const o = {}; const u = function () {
        const r = e ? Zt : nr; c(o, (n, t) => {
          cn(t) == _t && (n == gi.c ? r.addClass(t) : r.attr(n, t))
        })
      }; const f = [rn, en, Ee, He, on, un, fn, Le, Ne, Re, We, Ve, an, zn, Qr].join(Ie); const a = {}; nr = nr || (Mt ? v ? Zt[n]()[n]()[n]()[n]() : xi(li(en)) : Zt), or = or || vt(xn + r), ir = ir || vt(wn + r), er = er || vt(mn + r), rr = rr || vt('os-resize-observer-host'), ar = ar || (Mt ? vt(gn) : bi), e && pi(nr, f), i = cn(i) == _t ? i.split(Ie) : i, cn(i) == xt && Mt && c(i, (n, t) => {
        cn(t) == _t && (o[t] = e ? nr.attr(t) : Zt.attr(t))
      }), e ? (v && Wt ? (rr.children().remove(), c([er, ir, or, ar], (n, t) => {
        t && pi(t.removeAttr(gi.s), Dn)
      }), di(nr, Mt ? en : rn)) : (dt(rr), or.contents().unwrap().unwrap().unwrap(), Mt && (Zt.unwrap(), dt(nr), dt(ar), u())), Mt && Zt.removeAttr(gi.s), Ft && pi(h, tn)) : (Mt && (Gt.sizeAutoCapable || (a[xe] = Zt.css(xe), a[_e] = Zt.css(_e)), v || Zt.addClass(zn).wrap(nr), nr = Zt[n]().css(a)), v || (di(Zt, Mt ? t : rn), nr.wrapInner(or).wrapInner(ir).wrapInner(er).prepend(rr), or = pt(nr, N + xn), ir = pt(nr, N + wn), er = pt(nr, N + mn), Mt && (or.prepend(ar), u())), Lt && di(ir, De), Tt.x && Tt.y && di(ir, yn), Ft && di(h, tn), H = rr[0], lr = nr[0], hr = er[0], dr = ir[0], pr = or[0], rt())
    } function ot() {
      let r; let t; const e = [112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 123, 33, 34, 37, 38, 39, 40, 16, 17, 18, 19, 20, 144]; let i = []; const n = 'focus'; function o(n) {
        Ze(), It.update(ze), n && Et && clearInterval(r)
      }Mt ? (R > 9 || !Et ? Xn(Zt, 'input', o) : Xn(Zt, [$, G], [function u(n) {
        const t = n.keyCode; sn(t, e) < 0 && (i[gi.l] || (o(), r = setInterval(o, 1e3 / 60)), sn(t, i) < 0 && i.push(t))
      }, function f(n) {
        const t = n.keyCode; const r = sn(t, i); sn(t, e) < 0 && (r > -1 && i.splice(r, 1), i[gi.l] || o(!0))
      }]), Xn(Zt, [ke, 'drop', n, `${n}out`], [function a(n) {
        return Zt[Te](Ht.i && Br ? 9999999 : 0), Zt[Ae](0), mi.prvD(n), mi.stpP(n), !1
      }, function c(n) {
        setTimeout(() => {
          Dt || o()
        }, 50)
      }, function s() {
        Zr = !0, di(nr, n)
      }, function l() {
        Zr = !1, i = [], pi(nr, n), o(!0)
      }])) : Xn(or, J, (n) => {
        !0 !== Rr && (function l(n) {
          if (!Wt) {
            return 1
          } const t = 'flex-grow'; const r = 'flex-shrink'; const e = 'flex-basis'; const i = [xe, we + xe, ye + xe, ve + me, ve + be, me, be, 'font-weight', 'word-spacing', t, r, e]; const o = [he + me, he + be, de + me + xe, de + be + xe]; const u = [_e, we + _e, ye + _e, ve + pe, ve + ge, pe, ge, 'line-height', t, r, e]; const f = [he + pe, he + ge, de + pe + xe, de + ge + xe]; const a = Er.x === 's' || Er.x === 'v-s'; let c = !1; const s = function (n, t) {
            for (let r = 0; r < n[gi.l]; r++) {
              if (n[r] === t) {
                return !0 
} 
} return !1
          }; return (Er.y === 's' || Er.y === 'v-s') && ((c = s(u, n)) || jt || (c = s(f, n))), a && !c && ((c = s(i, n)) || jt || (c = s(o, n))), c
        }((n = n.originalEvent || n).propertyName)) && It.update(ze)
      }), Xn(ir, ke, (n) => {
        $t || (t !== bi ? clearTimeout(t) : ((re || ee) && ri(!0), lt() || di(nr, Le), fi('onScrollStart', n)), j || (ii(!0), ii(!1)), fi('onScroll', n), t = setTimeout(() => {
          Dt || (clearTimeout(t), t = bi, (re || ee) && ri(!1), lt() || pi(nr, Le), fi('onScrollStop', n))
        }, 175))
      }, !0)
    } function ut(i) {
      let n; let t; const o = function (n) {
        const t = vt(kn + Ie + (n ? Nn : Rn), !0); const r = vt(Cn, t); const e = vt(Tn, t); return v || i || (t.append(r), r.append(e)), {
          in:t,
          un:r,
          an:e
        }
      }; function r(n) {
        const t = ui(n); const r = t.in; const e = t.un; const i = t.an; v && Wt ? c([r, e, i], (n, t) => {
          pi(t.removeAttr(gi.s), Dn)
        }) : dt(r || o(n).in)
      }i ? (r(!0), r()) : (n = o(!0), t = o(), a = n.in, s = n.un, d = n.an, p = t.in, b = t.un, g = t.an, v || (er.after(p), er.after(a)))
    } function ft(_) {
      let O; let i; let S; let z; const r = ui(_); const k = r.cn; const t = y.top !== y; const C = r.B; const e = r.G; const I = ke + r.$; const o = 'active'; const u = 'snapHandle'; let T = 1; const f = [16, 17]; function a(n) {
        return R && t ? n[`screen${e}`] : mi.page(n)[C]
      } function c(n) {
        return Gt.scrollbars[n]
      } function s() {
        T = 0.5
      } function l() {
        T = 1
      } function v(n) {
        sn(n.keyCode, f) > -1 && s()
      } function A(n) {
        sn(n.keyCode, f) > -1 && l()
      } function H(n) {
        const t = (n.originalEvent || n).touches !== bi; return !($t || Dt || lt() || !jr || t && !c('touchSupport')) && (mi.mBtn(n) === 1 || t)
      } function h(n) {
        if (H(n)) {
          const t = k.M; const r = k.W; let e = k.N * ((a(n) - S) * z / (t - r)); e = isFinite(e) ? e : 0, Yt && _ && !Ht.i && (e *= -1), ir[I](wi.round(i + e)), j && ii(_, i + e), m || mi.prvD(n)
        } else {
          E(n)
        }
      } function E(n) {
        if (n = n || n.originalEvent, qn(D, [q, V, $, G, K], [h, E, v, A, Zn], !0), j && ii(_, !0), j = !1, pi(M, Wn), pi(r.an, o), pi(r.un, o), pi(r.in, o), z = 1, l(), O !== (S = i = bi) && (It.scrollStop(), clearTimeout(O), O = bi), n) {
          const t = lr[gi.bCR](); n.clientX >= t.left && n.clientX <= t.right && n.clientY >= t.top && n.clientY <= t.bottom || Kn(), (re || ee) && ri(!1)
        }
      } function L(n) {
        i = ir[I](), i = isNaN(i) ? 0 : i, (Yt && _ && !Ht.n || !Yt) && (i = i < 0 ? 0 : i), z = ct()[C], S = a(n), j = !c(u), di(M, Wn), di(r.an, o), di(r.in, o), qn(D, [q, V, K], [h, E, Zn]), !R && w || mi.prvD(n), mi.stpP(n)
      }Xn(r.an, U, (n) => {
        H(n) && L(n)
      }), Xn(r.un, [U, X, Y], [function N(n) {
        if (H(n)) {
          let h; const d = wi.round(se[r.j]); const p = r.un.offset()[r.P]; const t = n.ctrlKey; const b = n.shiftKey; const g = b && t; let m = !0; const w = function (n) {
            j && ii(_, n)
          }; const y = function () {
            w(), L(n)
          }; var x = function () {
            if (!Dt) {
              const n = (S - p) * z; const t = k.R; const r = k.M; const e = k.W; const i = k.N; const o = k.H; const u = 270 * T; const f = m ? wi.max(400, u) : u; let a = i * ((n - e / 2) / (r - e)); const c = Yt && _ && (!Ht.i && !Ht.n || Br); const s = c ? t < n : n < t; const l = {}; const v = {
                easing:'linear',
                step(n) {
                  j && (ir[I](n), ii(_, n))
                }
              }; a = isFinite(a) ? a : 0, a = Yt && _ && !Ht.i ? i - a : a, b ? (ir[I](a), g ? (a = ir[I](), ir[I](o), a = c && Ht.i ? i - a : a, a = c && Ht.n ? -a : a, l[C] = a, It.scroll(l, hi(v, {
                duration:130,
                complete:y
              }))) : y()) : (h = m ? s : h, (c ? h ? n <= t + e : t <= n : h ? t <= n : n <= t + e) ? (clearTimeout(O), It.scrollStop(), O = bi, w(!0)) : (O = setTimeout(x, f), l[C] = (h ? '-=' : '+=') + d, It.scroll(l, hi(v, {
                duration:u
              }))), m = !1)
            }
          }; t && s(), z = ct()[C], S = mi.page(n)[C], j = !c(u), di(M, Wn), di(r.un, o), di(r.in, o), qn(D, [V, $, G, K], [E, v, A, Zn]), x(), mi.prvD(n), mi.stpP(n)
        }
      }, function p(n) {
        F = !0, (re || ee) && ri(!0)
      }, function b(n) {
        F = !1, (re || ee) && ri(!1)
      }]), Xn(r.in, U, (n) => {
        mi.stpP(n)
      }), W && Xn(r.in, J, (n) => {
        n.target === r.in[0] && (ei(_), ii(_))
      })
    } function ti(n, t, r) {
      const e = n ? on : un; const i = n ? a : p; (t ? pi : di)(nr, e), (r ? pi : di)(i, Hn)
    } function ri(n, t) {
      if (clearTimeout(C), n) {
        pi(a, En), pi(p, En)
      } else {
        let r; const e = function () {
          F || Dt || (!(r = d.hasClass('active') || g.hasClass('active')) && (re || ee || ie) && di(a, En), !r && (re || ee || ie) && di(p, En))
        }; ne > 0 && !0 !== t ? C = setTimeout(e, ne) : e()
      }
    } function ei(n) {
      const t = {}; const r = ui(n); const e = r.cn; const i = wi.min(1, (br[r.j] - (Tr ? n ? Bt : Qt : 0)) / gr[r.j]); t[r.Y] = `${wi.floor(100 * i * 1e6) / 1e6}%`, lt() || r.an.css(t), e.W = r.an[0][`offset${r.sn}`], e.D = i
    } function ii(n, t) {
      let r; let e; const i = cn(t) == Ot; const o = Yt && n; const u = ui(n); const f = u.cn; const a = 'translate('; const c = zt.v('transform'); const s = zt.v('transition'); const l = n ? ir[Te]() : ir[Ae](); const v = t === bi || i ? l : t; const h = f.W; const d = u.un[0][`offset${u.sn}`]; const p = d - h; const b = {}; const g = (dr[ke + u.sn] - dr[`client${u.sn}`]) * (Ht.n && o ? -1 : 1); const m = function (n) {
        return isNaN(n / g) ? 0 : wi.max(0, wi.min(1, n / g))
      }; const w = function (n) {
        let t = p * n; return t = isNaN(t) ? 0 : t, t = o && !Ht.i ? d - h - t : t, t = wi.max(0, t)
      }; const y = m(l); const x = w(m(v)); const _ = w(y); f.N = g, f.H = l, f.L = y, ln ? (r = o ? -(d - h - x) : x, e = n ? `${a + r}px, 0)` : `${a}0, ${r}px)`, b[c] = e, W && (b[s] = i && wi.abs(x - f.R) > 1 ? `${(function O(n) {
        const t = zt.v('transition'); const r = n.css(t); if (r) {
          return r 
} for (var e, i, o, u = '\\s*(([^,(]+(\\(.+?\\))?)+)[\\s,]*', f = new RegExp(u), a = new RegExp(`^(${u})+$`), c = 'property duration timing-function delay'.split(' '), s = [], l = 0, v = function (n) {
          if (e = [], !n.match(a)) {
            return n 
} for (;n.match(f);) {
            e.push(RegExp.$1), n = n.replace(f, Se)
          } return e
        }; l < c[gi.l]; l++) {
          for (i = v(n.css(`${t}-${c[l]}`)), o = 0; o < i[gi.l]; o++) {
            s[o] = (s[o] ? s[o] + Ie : Se) + i[o] 
} 
} return s.join(', ')
      }(u.an))}, ${c + Ie + 250}ms` : Se)) : b[u.P] = x, lt() || (u.an.css(b), ln && W && i && u.an.one(J, () => {
        Dt || u.an.css(s, Se)
      })), f.R = x, f.F = _, f.M = d
    } function oi(n, t) {
      const r = t ? 'removeClass' : 'addClass'; const e = n ? b : g; const
        i = n ? In : An; (n ? s : d)[r](i), e[r](i)
    } function ui(n) {
      return {
        Y:n ? xe : _e,
        sn:n ? 'Width' : 'Height',
        P:n ? me : pe,
        $:n ? 'Left' : 'Top',
        B:n ? pn : bn,
        G:n ? 'X' : 'Y',
        j:n ? 'w' : 'h',
        ln:n ? 'l' : 't',
        un:n ? s : b,
        an:n ? d : g,
        in:n ? a : p,
        cn:n ? vn : hn
      }
    } function at(n) {
      cr = cr || vt(Ln, !0), n ? v && Wt ? pi(cr.removeAttr(gi.s), Dn) : dt(cr) : v || nr.append(cr)
    } function fi(n, t) {
      if (Wt) {
        let r; const e = Gt.callbacks[n]; let i = n; i.substr(0, 2) === 'on' && (i = i.substr(2, 1).toLowerCase() + i.substr(3)), cn(e) == yt && e.call(It, t), c(jn, function () {
          cn((r = this).on) == yt && r.on(i, t)
        })
      } else {
        Dt || Mn.push({
          n,
          a:t
        })
      }
    } function ai(n, t, r) {
      r === bi && (r = [Se, Se, Se, Se]), n[t + pe] = r[0], n[t + be] = r[1], n[t + ge] = r[2], n[t + me] = r[3]
    } function ct() {
      const n = hr[gi.bCR](); return {
        x:ln && 1 / (wi.round(n.width) / hr[gi.oW]) || 1,
        y:ln && 1 / (wi.round(n.height) / hr[gi.oH]) || 1
      }
    } function st(n) {
      const t = 'ownerDocument'; const r = 'HTMLElement'; const e = n && n[t] && n[t].parentWindow || gt; return typeof e[r] === wt ? n instanceof e[r] : n && typeof n === wt && n !== null && n.nodeType === 1 && typeof n.nodeName === _t
    } function ci(n, t) {
      const r = t ? parseFloat(n) : parseInt(n, 10); return isNaN(r) ? 0 : r
    } function lt() {
      return Nr && Tt.x && Tt.y
    } function si() {
      return Mt ? ar[0] : pr
    } function li(r, n) {
      return `<div ${r ? cn(r) == _t ? `class="${r}"` : (function () {
        let n; let t = Se; if (xi.isPlainObject(r)) {
          for (n in r) {
            t += `${n === 'c' ? 'class' : n}="${r[n]}" `;
          }
        } return t
      }()) : Se}>${n || Se}</div>`
    } function vt(n, t) {
      const r = cn(t) == Ot; const e = !r && t || nr; return v && !e[gi.l] ? null : v ? e[r ? 'children' : 'find'](N + n.replace(/\s/g, N)).eq(0) : xi(li(n))
    } function ht(n, t) {
      for (var r, e = t.split(N), i = 0; i < e.length; i++) {
        if (!n[gi.hOP](e[i])) {
          return
        } r = n[e[i]], i < e.length && cn(r) == wt && (n = r)
      } return r
    } function vi(n, t, r) {
      if (r) {
        return r
      } if (cn(n) != wt || cn(t) != wt) {
        return n !== t
      } for (const e in n) {
        if (e !== 'c') {
          if (!n[gi.hOP](e) || !t[gi.hOP](e)) {
            return !0
          } if (vi(n[e], t[e])) {
            return !0
          }
        }
      } return !1
    } function hi() {
      return xi.extend.apply(this, [!0].concat([].slice.call(arguments)))
    } function di(n, t) {
      return e.addClass.call(n, t)
    } function pi(n, t) {
      return e.removeClass.call(n, t)
    } function dt(n) {
      return e.remove.call(n)
    } function pt(n, t) {
      return e.find.call(n, t).eq(0)
    }
  } return yi && yi.fn && (yi.fn.overlayScrollbars = function (n, t) {
    return yi.isPlainObject(n) ? (yi.each(this, function () {
      X(this, n, t)
    }), this) : X(this, n)
  }), X
}))
