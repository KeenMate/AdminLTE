/*
 Copyright (C) Federico Zivolo 2020
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */function a(a, b) {
  if (a.nodeType !== 1) {
    return []
  } const c = a.ownerDocument.defaultView; const d = c.getComputedStyle(a, null); return b ? d[b] : d
} function b(a) {
  return a.nodeName === 'HTML' ? a : a.parentNode || a.host
} function c(d) {
  if (!d) {
    return document.body
  } switch (d.nodeName) {
    case 'HTML':case 'BODY':return d.ownerDocument.body; case '#document':return d.body
  } const e = a(d); const f = e.overflow; const g = e.overflowX; const h = e.overflowY; return /(auto|scroll|overlay)/.test(f + h + g) ? d : c(b(d))
} function d(a) {
  return a && a.referenceNode ? a.referenceNode : a
} const e = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined'; const f = e && Boolean(window.MSInputMethodContext && document.documentMode); const g = e && /MSIE 10/.test(navigator.userAgent); function h(a) {
  return a === 11 ? f : a === 10 ? g : f || g
} function i(b) {
  if (!b) {
    return document.documentElement
  } for (var c = h(10) ? document.body : null, d = b.offsetParent || null; d === c && b.nextElementSibling;) {
    d = (b = b.nextElementSibling).offsetParent
  } const e = d && d.nodeName; return e && e !== 'BODY' && e !== 'HTML' ? ['TH', 'TD', 'TABLE'].indexOf(d.nodeName) !== -1 && a(d, 'position') === 'static' ? i(d) : d : b ? b.ownerDocument.documentElement : document.documentElement
} function j(a) {
  const b = a.nodeName; return b !== 'BODY' && (b === 'HTML' || i(a.firstElementChild) === a)
} function k(a) {
  return a.parentNode === null ? a : k(a.parentNode)
} function l(a, b) {
  if (!a || !a.nodeType || !b || !b.nodeType) {
    return document.documentElement
  } const c = a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING; const d = c ? a : b; const e = c ? b : a; const f = document.createRange(); f.setStart(d, 0), f.setEnd(e, 0); const g = f.commonAncestorContainer; if (a !== g && b !== g || d.contains(e)) {
    return j(g) ? g : i(g)
  } const h = k(a); return h.host ? l(h.host, b) : l(a, k(b).host)
} function m(a) {
  const b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'top'; const c = b === 'top' ? 'scrollTop' : 'scrollLeft'; const d = a.nodeName; if (d === 'BODY' || d === 'HTML') {
    const e = a.ownerDocument.documentElement; const f = a.ownerDocument.scrollingElement || e; return f[c]
  } return a[c]
} function n(a, b) {
  const c = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const d = m(b, 'top'); const e = m(b, 'left'); const f = c ? -1 : 1; return a.top += d * f, a.bottom += d * f, a.left += e * f, a.right += e * f, a
} function o(a, b) {
  const c = b === 'x' ? 'Left' : 'Top'; const d = c == 'Left' ? 'Right' : 'Bottom'; return parseFloat(a[`border${c}Width`]) + parseFloat(a[`border${d}Width`])
} function p(a, b, c, d) {
  return Math.max(b[`offset${a}`], b[`scroll${a}`], c[`client${a}`], c[`offset${a}`], c[`scroll${a}`], h(10) ? parseInt(c[`offset${a}`]) + parseInt(d[`margin${a === 'Height' ? 'Top' : 'Left'}`]) + parseInt(d[`margin${a === 'Height' ? 'Bottom' : 'Right'}`]) : 0)
} function q(a) {
  const b = a.body; const c = a.documentElement; const d = h(10) && getComputedStyle(c); return {
    height:p('Height', b, c, d),
    width:p('Width', b, c, d)
  }
} const r = Object.assign || function (a) {
  for (var b, c = 1; c < arguments.length; c++) {
    for (const d in b = arguments[c], b) {
      Object.prototype.hasOwnProperty.call(b, d) && (a[d] = b[d])
    }
  } return a
}; function s(a) {
  return r({}, a, {
    right:a.left + a.width,
    bottom:a.top + a.height
  })
} function t(b) {
  let c = {}; try {
    if (h(10)) {
      c = b.getBoundingClientRect(); const d = m(b, 'top'); const e = m(b, 'left'); c.top += d, c.left += e, c.bottom += d, c.right += e
    } else {
      c = b.getBoundingClientRect()
    }
  } catch (a) {} const f = {
    left:c.left,
    top:c.top,
    width:c.right - c.left,
    height:c.bottom - c.top
  }; const g = b.nodeName === 'HTML' ? q(b.ownerDocument) : {}; const i = g.width || b.clientWidth || f.width; const j = g.height || b.clientHeight || f.height; let k = b.offsetWidth - i; let l = b.offsetHeight - j; if (k || l) {
    const n = a(b); k -= o(n, 'x'), l -= o(n, 'y'), f.width -= k, f.height -= l
  } return s(f)
} function u(b, d) {
  const e = Math.max; const f = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const g = h(10); const i = d.nodeName === 'HTML'; const j = t(b); const k = t(d); const l = c(b); const m = a(d); const o = parseFloat(m.borderTopWidth); const p = parseFloat(m.borderLeftWidth); f && i && (k.top = e(k.top, 0), k.left = e(k.left, 0)); let q = s({
    top:j.top - k.top - o,
    left:j.left - k.left - p,
    width:j.width,
    height:j.height
  }); if (q.marginTop = 0, q.marginLeft = 0, !g && i) {
    const r = parseFloat(m.marginTop); const u = parseFloat(m.marginLeft); q.top -= o - r, q.bottom -= o - r, q.left -= p - u, q.right -= p - u, q.marginTop = r, q.marginLeft = u
  } return (g && !f ? d.contains(l) : d === l && l.nodeName !== 'BODY') && (q = n(q, d)), q
} function v(a) {
  const b = Math.max; const c = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const d = a.ownerDocument.documentElement; const e = u(a, d); const f = b(d.clientWidth, window.innerWidth || 0); const g = b(d.clientHeight, window.innerHeight || 0); const h = c ? 0 : m(d); const i = c ? 0 : m(d, 'left'); const j = {
    top:h - e.top + e.marginTop,
    left:i - e.left + e.marginLeft,
    width:f,
    height:g
  }; return s(j)
} function w(c) {
  const d = c.nodeName; if (d === 'BODY' || d === 'HTML') {
    return !1
  } if (a(c, 'position') === 'fixed') {
    return !0
  } const e = b(c); return Boolean(e) && w(e)
} function x(b) {
  if (!b || !b.parentElement || h()) {
    return document.documentElement
  } for (var c = b.parentElement; c && a(c, 'transform') === 'none';) {
    c = c.parentElement
  } return c || document.documentElement
} function y(a, e, f, g) {
  const h = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; let i = {
    top:0,
    left:0
  }; const j = h ? x(a) : l(a, d(e)); if (g === 'viewport') {
    i = v(j, h)
  } else {
    let k; g === 'scrollParent' ? (k = c(b(e)), k.nodeName === 'BODY' && (k = a.ownerDocument.documentElement)) : g === 'window' ? k = a.ownerDocument.documentElement : k = g; const m = u(k, j, h); if (k.nodeName === 'HTML' && !w(j)) {
      const n = q(a.ownerDocument); const o = n.height; const p = n.width; i.top += m.top - m.marginTop, i.bottom = o + m.top, i.left += m.left - m.marginLeft, i.right = p + m.left
    } else {
      i = m
    }
  }f = f || 0; const r = typeof f === 'number'; return i.left += r ? f : f.left || 0, i.top += r ? f : f.top || 0, i.right -= r ? f : f.right || 0, i.bottom -= r ? f : f.bottom || 0, i
} function z(a) {
  const b = a.width; const c = a.height; return b * c
} function A(a, b, c, d, e) {
  const f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0; if (a.indexOf('auto') === -1) {
    return a
  } const g = y(c, d, f, e); const h = {
    top:{
      width:g.width,
      height:b.top - g.top
    },
    right:{
      width:g.right - b.right,
      height:g.height
    },
    bottom:{
      width:g.width,
      height:g.bottom - b.bottom
    },
    left:{
      width:b.left - g.left,
      height:g.height
    }
  }; const i = Object.keys(h).map((a) => r({
    key:a
  }, h[a], {
    area:z(h[a])
  })).sort((c, a) => a.area - c.area); const j = i.filter((a) => {
    const b = a.width; const d = a.height; return b >= c.clientWidth && d >= c.clientHeight
  }); const k = j.length > 0 ? j[0].key : i[0].key; const l = a.split('-')[1]; return k + (l ? `-${l}` : '')
} const B = (function () {
  for (let a = ['Edge', 'Trident', 'Firefox'], b = 0; b < a.length; b += 1) {
    if (e && navigator.userAgent.indexOf(a[b]) >= 0) {
      return 1
    }
  } return 0
}()); function C(a) {
  let b = !1; return function () {
    b || (b = !0, window.Promise.resolve().then(() => {
      b = !1, a()
    }))
  }
} function D(a) {
  let b = !1; return function () {
    b || (b = !0, setTimeout(() => {
      b = !1, a()
    }, B))
  }
} const E = e && window.Promise; const F = E ? C : D; function G(a, b) {
  return Array.prototype.find ? a.find(b) : a.filter(b)[0]
} function H(a, b, c) {
  if (Array.prototype.findIndex) {
    return a.findIndex((a) => a[b] === c)
  } const d = G(a, (a) => a[b] === c); return a.indexOf(d)
} function I(a) {
  let b; if (a.nodeName === 'HTML') {
    const c = q(a.ownerDocument); const d = c.width; const e = c.height; b = {
      width:d,
      height:e,
      left:0,
      top:0
    }
  } else {
    b = {
      width:a.offsetWidth,
      height:a.offsetHeight,
      left:a.offsetLeft,
      top:a.offsetTop
    }
  } return s(b)
} function J(a) {
  const b = a.ownerDocument.defaultView; const c = b.getComputedStyle(a); const d = parseFloat(c.marginTop || 0) + parseFloat(c.marginBottom || 0); const e = parseFloat(c.marginLeft || 0) + parseFloat(c.marginRight || 0); const f = {
    width:a.offsetWidth + e,
    height:a.offsetHeight + d
  }; return f
} function K(a) {
  const b = {
    left:'right',
    right:'left',
    bottom:'top',
    top:'bottom'
  }; return a.replace(/left|right|bottom|top/g, (a) => b[a])
} function L(a, b, c) {
  c = c.split('-')[0]; const d = J(a); const e = {
    width:d.width,
    height:d.height
  }; const f = ['right', 'left'].indexOf(c) !== -1; const g = f ? 'top' : 'left'; const h = f ? 'left' : 'top'; const i = f ? 'height' : 'width'; const j = f ? 'width' : 'height'; return e[g] = b[g] + b[i] / 2 - d[i] / 2, e[h] = c === h ? b[h] - d[j] : b[K(h)], e
} function M(a, b, c) {
  const e = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null; const f = e ? x(b) : l(b, d(c)); return u(c, f, e)
} function N(a) {
  for (let b = [!1, 'ms', 'Webkit', 'Moz', 'O'], c = a.charAt(0).toUpperCase() + a.slice(1), d = 0; d < b.length; d++) {
    const e = b[d]; const f = e ? String(e) + c : a; if (typeof document.body.style[f] !== 'undefined') {
      return f
    }
  } return null
} function O(a) {
  return a && {}.toString.call(a) === '[object Function]'
} function P(a, b) {
  return a.some((a) => {
    const c = a.name; const d = a.enabled; return d && c === b
  })
} function Q(a, b, c) {
  const d = G(a, (a) => {
    const c = a.name; return c === b
  }); const e = Boolean(d) && a.some((a) => a.name === c && a.enabled && a.order < d.order); if (!e) {
    const f = `\`${b}\``; console.warn(`\`${c}\`` + ` modifier is required by ${f} modifier in order to work, be sure to include it before ${f}!`)
  } return e
} function R(a) {
  return a !== '' && !isNaN(parseFloat(a)) && isFinite(a)
} function S(a) {
  const b = a.ownerDocument; return b ? b.defaultView : window
} function T(a, b) {
  return S(a).removeEventListener('resize', b.updateBound), b.scrollParents.forEach((a) => {
    a.removeEventListener('scroll', b.updateBound)
  }), b.updateBound = null, b.scrollParents = [], b.scrollElement = null, b.eventsEnabled = !1, b
} function U(a, b, c) {
  const d = void 0 === c ? a : a.slice(0, H(a, 'name', c)); return d.forEach((a) => {
    a.function && console.warn('`modifier.function` is deprecated, use `modifier.fn`!'); const c = a.function || a.fn; a.enabled && O(c) && (b.offsets.popper = s(b.offsets.popper), b.offsets.reference = s(b.offsets.reference), b = c(b, a))
  }), b
} function V(a, b) {
  Object.keys(b).forEach((c) => {
    const d = b[c]; !1 === d ? a.removeAttribute(c) : a.setAttribute(c, b[c])
  })
} function W(a, b) {
  Object.keys(b).forEach((c) => {
    let d = ''; ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(c) !== -1 && R(b[c]) && (d = 'px'), a.style[c] = b[c] + d
  })
} function X(a, b, d, e) {
  const f = a.nodeName === 'BODY'; const g = f ? a.ownerDocument.defaultView : a; g.addEventListener(b, d, {
    passive:!0
  }), f || X(c(g.parentNode), b, d, e), e.push(g)
} function Y(a, b, d, e) {
  d.updateBound = e, S(a).addEventListener('resize', d.updateBound, {
    passive:!0
  }); const f = c(a); return X(f, 'scroll', d.updateBound, d.scrollParents), d.scrollElement = f, d.eventsEnabled = !0, d
} const Z = {
  computeAutoPlacement:A,
  debounce:F,
  findIndex:H,
  getBordersSize:o,
  getBoundaries:y,
  getBoundingClientRect:t,
  getClientRect:s,
  getOffsetParent:i,
  getOffsetRect:I,
  getOffsetRectRelativeToArbitraryNode:u,
  getOuterSizes:J,
  getParentNode:b,
  getPopperOffsets:L,
  getReferenceOffsets:M,
  getScroll:m,
  getScrollParent:c,
  getStyleComputedProperty:a,
  getSupportedPropertyName:N,
  getWindowSizes:q,
  isFixed:w,
  isFunction:O,
  isModifierEnabled:P,
  isModifierRequired:Q,
  isNumeric:R,
  removeEventListeners:T,
  runModifiers:U,
  setAttributes:V,
  setStyles:W,
  setupEventListeners:Y
}; export {
  A as computeAutoPlacement, F as debounce, H as findIndex, o as getBordersSize, y as getBoundaries, t as getBoundingClientRect, s as getClientRect, i as getOffsetParent, I as getOffsetRect, u as getOffsetRectRelativeToArbitraryNode, J as getOuterSizes, b as getParentNode, L as getPopperOffsets, M as getReferenceOffsets, m as getScroll, c as getScrollParent, a as getStyleComputedProperty, N as getSupportedPropertyName, q as getWindowSizes, w as isFixed, O as isFunction, P as isModifierEnabled, Q as isModifierRequired, R as isNumeric, T as removeEventListeners, U as runModifiers, V as setAttributes, W as setStyles, Y as setupEventListeners
}; export default Z
// # sourceMappingURL=popper-utils.min.js.map
