/*
 Copyright (C) Federico Zivolo 2020
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */function a(a, b) {
  if (a.nodeType !== 1) {
    return []
  } const c = a.ownerDocument.defaultView; const d = c.getComputedStyle(a, null); return b ? d[b] : d
} function b(a) {
  return a.nodeName === 'HTML' ? a : a.parentNode || a.host
} function c(d) {
  if (!d) {
    return document.body
  } switch (d.nodeName) {
    case 'HTML':case 'BODY':return d.ownerDocument.body; case '#document':return d.body
  } const {
    overflow:e, overflowX:f, overflowY:g
  } = a(d); return /(auto|scroll|overlay)/.test(e + g + f) ? d : c(b(d))
} function d(a) {
  return a && a.referenceNode ? a.referenceNode : a
} const e = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined'; const f = e && Boolean(window.MSInputMethodContext && document.documentMode); const g = e && /MSIE 10/.test(navigator.userAgent); function h(a) {
  return a === 11 ? f : a === 10 ? g : f || g
} function i(b) {
  if (!b) {
    return document.documentElement
  } const c = h(10) ? document.body : null; let d = b.offsetParent || null; for (;d === c && b.nextElementSibling;) {
    d = (b = b.nextElementSibling).offsetParent
  } const e = d && d.nodeName; return e && e !== 'BODY' && e !== 'HTML' ? ['TH', 'TD', 'TABLE'].indexOf(d.nodeName) !== -1 && a(d, 'position') === 'static' ? i(d) : d : b ? b.ownerDocument.documentElement : document.documentElement
} function j(a) {
  const {
    nodeName:b
  } = a; return b !== 'BODY' && (b === 'HTML' || i(a.firstElementChild) === a)
} function k(a) {
  return a.parentNode === null ? a : k(a.parentNode)
} function l(a, b) {
  if (!a || !a.nodeType || !b || !b.nodeType) {
    return document.documentElement
  } const c = a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING; const d = c ? a : b; const e = c ? b : a; const f = document.createRange(); f.setStart(d, 0), f.setEnd(e, 0); const {
    commonAncestorContainer:g
  } = f; if (a !== g && b !== g || d.contains(e)) {
    return j(g) ? g : i(g)
  } const h = k(a); return h.host ? l(h.host, b) : l(a, k(b).host)
} function m(a, b = 'top') {
  const c = b === 'top' ? 'scrollTop' : 'scrollLeft'; const d = a.nodeName; if (d === 'BODY' || d === 'HTML') {
    const b = a.ownerDocument.documentElement; const d = a.ownerDocument.scrollingElement || b; return d[c]
  } return a[c]
} function n(a, b, c = !1) {
  const d = m(b, 'top'); const e = m(b, 'left'); const f = c ? -1 : 1; return a.top += d * f, a.bottom += d * f, a.left += e * f, a.right += e * f, a
} function o(a, b) {
  const c = b === 'x' ? 'Left' : 'Top'; const d = c == 'Left' ? 'Right' : 'Bottom'; return parseFloat(a[`border${c}Width`]) + parseFloat(a[`border${d}Width`])
} function p(a, b, c, d) {
  return Math.max(b[`offset${a}`], b[`scroll${a}`], c[`client${a}`], c[`offset${a}`], c[`scroll${a}`], h(10) ? parseInt(c[`offset${a}`]) + parseInt(d[`margin${a === 'Height' ? 'Top' : 'Left'}`]) + parseInt(d[`margin${a === 'Height' ? 'Bottom' : 'Right'}`]) : 0)
} function q(a) {
  const b = a.body; const c = a.documentElement; const d = h(10) && getComputedStyle(c); return {
    height:p('Height', b, c, d),
    width:p('Width', b, c, d)
  }
} const r = Object.assign || function (a) {
  for (var b, c = 1; c < arguments.length; c++) {
    for (const d in b = arguments[c], b) {
      Object.prototype.hasOwnProperty.call(b, d) && (a[d] = b[d])
    }
  } return a
}; function s(a) {
  return r({}, a, {
    right:a.left + a.width,
    bottom:a.top + a.height
  })
} function t(b) {
  let c = {}; try {
    if (h(10)) {
      c = b.getBoundingClientRect(); const a = m(b, 'top'); const d = m(b, 'left'); c.top += a, c.left += d, c.bottom += a, c.right += d
    } else {
      c = b.getBoundingClientRect()
    }
  } catch (a) {} const d = {
    left:c.left,
    top:c.top,
    width:c.right - c.left,
    height:c.bottom - c.top
  }; const e = b.nodeName === 'HTML' ? q(b.ownerDocument) : {}; const f = e.width || b.clientWidth || d.width; const g = e.height || b.clientHeight || d.height; let i = b.offsetWidth - f; let j = b.offsetHeight - g; if (i || j) {
    const c = a(b); i -= o(c, 'x'), j -= o(c, 'y'), d.width -= i, d.height -= j
  } return s(d)
} function u(b, d, e = !1) {
  const f = Math.max; const g = h(10); const i = d.nodeName === 'HTML'; const j = t(b); const k = t(d); const l = c(b); const m = a(d); const o = parseFloat(m.borderTopWidth); const p = parseFloat(m.borderLeftWidth); e && i && (k.top = f(k.top, 0), k.left = f(k.left, 0)); let q = s({
    top:j.top - k.top - o,
    left:j.left - k.left - p,
    width:j.width,
    height:j.height
  }); if (q.marginTop = 0, q.marginLeft = 0, !g && i) {
    const a = parseFloat(m.marginTop); const b = parseFloat(m.marginLeft); q.top -= o - a, q.bottom -= o - a, q.left -= p - b, q.right -= p - b, q.marginTop = a, q.marginLeft = b
  } return (g && !e ? d.contains(l) : d === l && l.nodeName !== 'BODY') && (q = n(q, d)), q
} function v(a, b = !1) {
  const c = Math.max; const d = a.ownerDocument.documentElement; const e = u(a, d); const f = c(d.clientWidth, window.innerWidth || 0); const g = c(d.clientHeight, window.innerHeight || 0); const h = b ? 0 : m(d); const i = b ? 0 : m(d, 'left'); const j = {
    top:h - e.top + e.marginTop,
    left:i - e.left + e.marginLeft,
    width:f,
    height:g
  }; return s(j)
} function w(c) {
  const d = c.nodeName; if (d === 'BODY' || d === 'HTML') {
    return !1
  } if (a(c, 'position') === 'fixed') {
    return !0
  } const e = b(c); return Boolean(e) && w(e)
} function x(b) {
  if (!b || !b.parentElement || h()) {
    return document.documentElement
  } let c = b.parentElement; for (;c && a(c, 'transform') === 'none';) {
    c = c.parentElement
  } return c || document.documentElement
} function y(a, e, f, g, h = !1) {
  let i = {
    top:0,
    left:0
  }; const j = h ? x(a) : l(a, d(e)); if (g === 'viewport') {
    i = v(j, h)
  } else {
    let d; g === 'scrollParent' ? (d = c(b(e)), d.nodeName === 'BODY' && (d = a.ownerDocument.documentElement)) : g === 'window' ? d = a.ownerDocument.documentElement : d = g; const f = u(d, j, h); if (d.nodeName === 'HTML' && !w(j)) {
      const {
        height:b, width:c
      } = q(a.ownerDocument); i.top += f.top - f.marginTop, i.bottom = b + f.top, i.left += f.left - f.marginLeft, i.right = c + f.left
    } else {
      i = f
    }
  }f = f || 0; const k = typeof f === 'number'; return i.left += k ? f : f.left || 0, i.top += k ? f : f.top || 0, i.right -= k ? f : f.right || 0, i.bottom -= k ? f : f.bottom || 0, i
} function z({
  width:a, height:b
}) {
  return a * b
} function A(a, b, c, d, e, f = 0) {
  if (a.indexOf('auto') === -1) {
    return a
  } const g = y(c, d, f, e); const h = {
    top:{
      width:g.width,
      height:b.top - g.top
    },
    right:{
      width:g.right - b.right,
      height:g.height
    },
    bottom:{
      width:g.width,
      height:g.bottom - b.bottom
    },
    left:{
      width:b.left - g.left,
      height:g.height
    }
  }; const i = Object.keys(h).map((a) => r({
    key:a
  }, h[a], {
    area:z(h[a])
  })).sort((c, a) => a.area - c.area); const j = i.filter(({
    width:a, height:b
  }) => a >= c.clientWidth && b >= c.clientHeight); const k = j.length > 0 ? j[0].key : i[0].key; const l = a.split('-')[1]; return k + (l ? `-${l}` : '')
} const B = (function () {
  const a = ['Edge', 'Trident', 'Firefox']; for (let b = 0; b < a.length; b += 1) {
    if (e && navigator.userAgent.indexOf(a[b]) >= 0) {
      return 1
    }
  } return 0
}()); function C(a) {
  let b = !1; return () => {
    b || (b = !0, window.Promise.resolve().then(() => {
      b = !1, a()
    }))
  }
} function D(a) {
  let b = !1; return () => {
    b || (b = !0, setTimeout(() => {
      b = !1, a()
    }, B))
  }
} const E = e && window.Promise; const F = E ? C : D; function G(a, b) {
  return Array.prototype.find ? a.find(b) : a.filter(b)[0]
} function H(a, b, c) {
  if (Array.prototype.findIndex) {
    return a.findIndex((a) => a[b] === c)
  } const d = G(a, (a) => a[b] === c); return a.indexOf(d)
} function I(a) {
  let b; if (a.nodeName === 'HTML') {
    const {
      width:c, height:d
    } = q(a.ownerDocument); b = {
      width:c,
      height:d,
      left:0,
      top:0
    }
  } else {
    b = {
      width:a.offsetWidth,
      height:a.offsetHeight,
      left:a.offsetLeft,
      top:a.offsetTop
    }
  } return s(b)
} function J(a) {
  const b = a.ownerDocument.defaultView; const c = b.getComputedStyle(a); const d = parseFloat(c.marginTop || 0) + parseFloat(c.marginBottom || 0); const e = parseFloat(c.marginLeft || 0) + parseFloat(c.marginRight || 0); const f = {
    width:a.offsetWidth + e,
    height:a.offsetHeight + d
  }; return f
} function K(a) {
  const b = {
    left:'right',
    right:'left',
    bottom:'top',
    top:'bottom'
  }; return a.replace(/left|right|bottom|top/g, (a) => b[a])
} function L(a, b, c) {
  c = c.split('-')[0]; const d = J(a); const e = {
    width:d.width,
    height:d.height
  }; const f = ['right', 'left'].indexOf(c) !== -1; const g = f ? 'top' : 'left'; const h = f ? 'left' : 'top'; const i = f ? 'height' : 'width'; const j = f ? 'width' : 'height'; return e[g] = b[g] + b[i] / 2 - d[i] / 2, e[h] = c === h ? b[h] - d[j] : b[K(h)], e
} function M(a, b, c, e = null) {
  const f = e ? x(b) : l(b, d(c)); return u(c, f, e)
} function N(a) {
  const b = [!1, 'ms', 'Webkit', 'Moz', 'O']; const c = a.charAt(0).toUpperCase() + a.slice(1); for (let d = 0; d < b.length; d++) {
    const e = b[d]; const f = e ? `${e}${c}` : a; if (typeof document.body.style[f] !== 'undefined') {
      return f
    }
  } return null
} function O(a) {
  return a && {}.toString.call(a) === '[object Function]'
} function P(a, b) {
  return a.some(({
    name:a, enabled:c
  }) => c && a === b)
} function Q(a, b, c) {
  const d = G(a, ({
    name:a
  }) => a === b); const e = Boolean(d) && a.some((a) => a.name === c && a.enabled && a.order < d.order); if (!e) {
    const a = `\`${b}\``; const d = `\`${c}\``; console.warn(`${d} modifier is required by ${a} modifier in order to work, be sure to include it before ${a}!`)
  } return e
} function R(a) {
  return a !== '' && !isNaN(parseFloat(a)) && isFinite(a)
} function S(a) {
  const b = a.ownerDocument; return b ? b.defaultView : window
} function T(a, b) {
  return S(a).removeEventListener('resize', b.updateBound), b.scrollParents.forEach((a) => {
    a.removeEventListener('scroll', b.updateBound)
  }), b.updateBound = null, b.scrollParents = [], b.scrollElement = null, b.eventsEnabled = !1, b
} function U(a, b, c) {
  const d = void 0 === c ? a : a.slice(0, H(a, 'name', c)); return d.forEach((a) => {
    a.function && console.warn('`modifier.function` is deprecated, use `modifier.fn`!'); const c = a.function || a.fn; a.enabled && O(c) && (b.offsets.popper = s(b.offsets.popper), b.offsets.reference = s(b.offsets.reference), b = c(b, a))
  }), b
} function V(a, b) {
  Object.keys(b).forEach((c) => {
    const d = b[c]; !1 === d ? a.removeAttribute(c) : a.setAttribute(c, b[c])
  })
} function W(a, b) {
  Object.keys(b).forEach((c) => {
    let d = ''; ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(c) !== -1 && R(b[c]) && (d = 'px'), a.style[c] = b[c] + d
  })
} function X(a, b, d, e) {
  const f = a.nodeName === 'BODY'; const g = f ? a.ownerDocument.defaultView : a; g.addEventListener(b, d, {
    passive:!0
  }), f || X(c(g.parentNode), b, d, e), e.push(g)
} function Y(a, b, d, e) {
  d.updateBound = e, S(a).addEventListener('resize', d.updateBound, {
    passive:!0
  }); const f = c(a); return X(f, 'scroll', d.updateBound, d.scrollParents), d.scrollElement = f, d.eventsEnabled = !0, d
} const Z = {
  computeAutoPlacement:A,
  debounce:F,
  findIndex:H,
  getBordersSize:o,
  getBoundaries:y,
  getBoundingClientRect:t,
  getClientRect:s,
  getOffsetParent:i,
  getOffsetRect:I,
  getOffsetRectRelativeToArbitraryNode:u,
  getOuterSizes:J,
  getParentNode:b,
  getPopperOffsets:L,
  getReferenceOffsets:M,
  getScroll:m,
  getScrollParent:c,
  getStyleComputedProperty:a,
  getSupportedPropertyName:N,
  getWindowSizes:q,
  isFixed:w,
  isFunction:O,
  isModifierEnabled:P,
  isModifierRequired:Q,
  isNumeric:R,
  removeEventListeners:T,
  runModifiers:U,
  setAttributes:V,
  setStyles:W,
  setupEventListeners:Y
}; export {
  A as computeAutoPlacement, F as debounce, H as findIndex, o as getBordersSize, y as getBoundaries, t as getBoundingClientRect, s as getClientRect, i as getOffsetParent, I as getOffsetRect, u as getOffsetRectRelativeToArbitraryNode, J as getOuterSizes, b as getParentNode, L as getPopperOffsets, M as getReferenceOffsets, m as getScroll, c as getScrollParent, a as getStyleComputedProperty, N as getSupportedPropertyName, q as getWindowSizes, w as isFixed, O as isFunction, P as isModifierEnabled, Q as isModifierRequired, R as isNumeric, T as removeEventListeners, U as runModifiers, V as setAttributes, W as setStyles, Y as setupEventListeners
}; export default Z
// # sourceMappingURL=popper-utils.min.js.map
