/*
 Copyright (C) Federico Zivolo 2020
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */(function (a, b) {
  typeof exports === 'object' && typeof module !== 'undefined' ? b(exports) : typeof define === 'function' && define.amd ? define(['exports'], b) : b(a.PopperUtils = {})
}(this, (a) => {
  function b(a, b) {
    if (a.nodeType !== 1) {
      return []
    } const c = a.ownerDocument.defaultView; const d = c.getComputedStyle(a, null); return b ? d[b] : d
  } function c(a) {
    return a.nodeName === 'HTML' ? a : a.parentNode || a.host
  } function d(a) {
    if (!a) {
      return document.body
    } switch (a.nodeName) {
      case 'HTML':case 'BODY':return a.ownerDocument.body; case '#document':return a.body
    } const e = b(a); const f = e.overflow; const g = e.overflowX; const h = e.overflowY; return /(auto|scroll|overlay)/.test(f + h + g) ? a : d(c(a))
  } function e(a) {
    return a && a.referenceNode ? a.referenceNode : a
  } function f(a) {
    return a === 11 ? T : a === 10 ? U : T || U
  } function g(a) {
    if (!a) {
      return document.documentElement
    } for (var c = f(10) ? document.body : null, d = a.offsetParent || null; d === c && a.nextElementSibling;) {
      d = (a = a.nextElementSibling).offsetParent
    } const e = d && d.nodeName; return e && e !== 'BODY' && e !== 'HTML' ? ['TH', 'TD', 'TABLE'].indexOf(d.nodeName) !== -1 && b(d, 'position') === 'static' ? g(d) : d : a ? a.ownerDocument.documentElement : document.documentElement
  } function h(a) {
    const b = a.nodeName; return b !== 'BODY' && (b === 'HTML' || g(a.firstElementChild) === a)
  } function i(a) {
    return a.parentNode === null ? a : i(a.parentNode)
  } function j(a, b) {
    if (!a || !a.nodeType || !b || !b.nodeType) {
      return document.documentElement
    } const c = a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING; const d = c ? a : b; const e = c ? b : a; const f = document.createRange(); f.setStart(d, 0), f.setEnd(e, 0); const k = f.commonAncestorContainer; if (a !== k && b !== k || d.contains(e)) {
      return h(k) ? k : g(k)
    } const l = i(a); return l.host ? j(l.host, b) : j(a, i(b).host)
  } function k(a) {
    const b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'top'; const c = b === 'top' ? 'scrollTop' : 'scrollLeft'; const d = a.nodeName; if (d === 'BODY' || d === 'HTML') {
      const e = a.ownerDocument.documentElement; const f = a.ownerDocument.scrollingElement || e; return f[c]
    } return a[c]
  } function l(a, b) {
    const c = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const d = k(b, 'top'); const e = k(b, 'left'); const f = c ? -1 : 1; return a.top += d * f, a.bottom += d * f, a.left += e * f, a.right += e * f, a
  } function m(a, b) {
    const c = b === 'x' ? 'Left' : 'Top'; const d = c == 'Left' ? 'Right' : 'Bottom'; return parseFloat(a[`border${c}Width`]) + parseFloat(a[`border${d}Width`])
  } function n(a, b, c, d) {
    return R(b[`offset${a}`], b[`scroll${a}`], c[`client${a}`], c[`offset${a}`], c[`scroll${a}`], f(10) ? parseInt(c[`offset${a}`]) + parseInt(d[`margin${a === 'Height' ? 'Top' : 'Left'}`]) + parseInt(d[`margin${a === 'Height' ? 'Bottom' : 'Right'}`]) : 0)
  } function o(a) {
    const b = a.body; const c = a.documentElement; const d = f(10) && getComputedStyle(c); return {
      height:n('Height', b, c, d),
      width:n('Width', b, c, d)
    }
  } function p(a) {
    return V({}, a, {
      right:a.left + a.width,
      bottom:a.top + a.height
    })
  } function q(a) {
    let c = {}; try {
      if (f(10)) {
        c = a.getBoundingClientRect(); const d = k(a, 'top'); const e = k(a, 'left'); c.top += d, c.left += e, c.bottom += d, c.right += e
      } else {
        c = a.getBoundingClientRect()
      }
    } catch (a) {} const g = {
      left:c.left,
      top:c.top,
      width:c.right - c.left,
      height:c.bottom - c.top
    }; const h = a.nodeName === 'HTML' ? o(a.ownerDocument) : {}; const i = h.width || a.clientWidth || g.width; const j = h.height || a.clientHeight || g.height; let l = a.offsetWidth - i; let n = a.offsetHeight - j; if (l || n) {
      const q = b(a); l -= m(q, 'x'), n -= m(q, 'y'), g.width -= l, g.height -= n
    } return p(g)
  } function r(a, c) {
    const e = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const g = f(10); const h = c.nodeName === 'HTML'; const i = q(a); const j = q(c); const k = d(a); const m = b(c); const n = parseFloat(m.borderTopWidth); const o = parseFloat(m.borderLeftWidth); e && h && (j.top = R(j.top, 0), j.left = R(j.left, 0)); let r = p({
      top:i.top - j.top - n,
      left:i.left - j.left - o,
      width:i.width,
      height:i.height
    }); if (r.marginTop = 0, r.marginLeft = 0, !g && h) {
      const s = parseFloat(m.marginTop); const t = parseFloat(m.marginLeft); r.top -= n - s, r.bottom -= n - s, r.left -= o - t, r.right -= o - t, r.marginTop = s, r.marginLeft = t
    } return (g && !e ? c.contains(k) : c === k && k.nodeName !== 'BODY') && (r = l(r, c)), r
  } function s(a) {
    const b = arguments.length > 1 && arguments[1] !== void 0 && arguments[1]; const c = a.ownerDocument.documentElement; const d = r(a, c); const e = R(c.clientWidth, window.innerWidth || 0); const f = R(c.clientHeight, window.innerHeight || 0); const g = b ? 0 : k(c); const h = b ? 0 : k(c, 'left'); const i = {
      top:g - d.top + d.marginTop,
      left:h - d.left + d.marginLeft,
      width:e,
      height:f
    }; return p(i)
  } function t(a) {
    const d = a.nodeName; if (d === 'BODY' || d === 'HTML') {
      return !1
    } if (b(a, 'position') === 'fixed') {
      return !0
    } const e = c(a); return Boolean(e) && t(e)
  } function u(a) {
    if (!a || !a.parentElement || f()) {
      return document.documentElement
    } for (var c = a.parentElement; c && b(c, 'transform') === 'none';) {
      c = c.parentElement
    } return c || document.documentElement
  } function v(a, b, f, g) {
    const h = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; let i = {
      top:0,
      left:0
    }; const k = h ? u(a) : j(a, e(b)); if (g === 'viewport') {
      i = s(k, h)
    } else {
      let l; g === 'scrollParent' ? (l = d(c(b)), l.nodeName === 'BODY' && (l = a.ownerDocument.documentElement)) : g === 'window' ? l = a.ownerDocument.documentElement : l = g; const m = r(l, k, h); if (l.nodeName === 'HTML' && !t(k)) {
        const n = o(a.ownerDocument); const p = n.height; const q = n.width; i.top += m.top - m.marginTop, i.bottom = p + m.top, i.left += m.left - m.marginLeft, i.right = q + m.left
      } else {
        i = m
      }
    }f = f || 0; const v = typeof f === 'number'; return i.left += v ? f : f.left || 0, i.top += v ? f : f.top || 0, i.right -= v ? f : f.right || 0, i.bottom -= v ? f : f.bottom || 0, i
  } function w(a) {
    const b = a.width; const c = a.height; return b * c
  } function x(a, b, c, d, e) {
    const f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0; if (a.indexOf('auto') === -1) {
      return a
    } const g = v(c, d, f, e); const h = {
      top:{
        width:g.width,
        height:b.top - g.top
      },
      right:{
        width:g.right - b.right,
        height:g.height
      },
      bottom:{
        width:g.width,
        height:g.bottom - b.bottom
      },
      left:{
        width:b.left - g.left,
        height:g.height
      }
    }; const i = Object.keys(h).map((a) => V({
      key:a
    }, h[a], {
      area:w(h[a])
    })).sort((c, a) => a.area - c.area); const j = i.filter((a) => {
      const b = a.width; const d = a.height; return b >= c.clientWidth && d >= c.clientHeight
    }); const k = j.length > 0 ? j[0].key : i[0].key; const l = a.split('-')[1]; return k + (l ? `-${l}` : '')
  } function y(a, b) {
    return Array.prototype.find ? a.find(b) : a.filter(b)[0]
  } function z(a, b, c) {
    if (Array.prototype.findIndex) {
      return a.findIndex((a) => a[b] === c)
    } const d = y(a, (a) => a[b] === c); return a.indexOf(d)
  } function A(a) {
    let b; if (a.nodeName === 'HTML') {
      const c = o(a.ownerDocument); const d = c.width; const e = c.height; b = {
        width:d,
        height:e,
        left:0,
        top:0
      }
    } else {
      b = {
        width:a.offsetWidth,
        height:a.offsetHeight,
        left:a.offsetLeft,
        top:a.offsetTop
      }
    } return p(b)
  } function B(a) {
    const b = a.ownerDocument.defaultView; const c = b.getComputedStyle(a); const d = parseFloat(c.marginTop || 0) + parseFloat(c.marginBottom || 0); const e = parseFloat(c.marginLeft || 0) + parseFloat(c.marginRight || 0); const f = {
      width:a.offsetWidth + e,
      height:a.offsetHeight + d
    }; return f
  } function C(a) {
    const b = {
      left:'right',
      right:'left',
      bottom:'top',
      top:'bottom'
    }; return a.replace(/left|right|bottom|top/g, (a) => b[a])
  } function D(a, b, c) {
    c = c.split('-')[0]; const d = B(a); const e = {
      width:d.width,
      height:d.height
    }; const f = ['right', 'left'].indexOf(c) !== -1; const g = f ? 'top' : 'left'; const h = f ? 'left' : 'top'; const i = f ? 'height' : 'width'; const j = f ? 'width' : 'height'; return e[g] = b[g] + b[i] / 2 - d[i] / 2, e[h] = c === h ? b[h] - d[j] : b[C(h)], e
  } function E(a, b, c) {
    const d = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null; const f = d ? u(b) : j(b, e(c)); return r(c, f, d)
  } function F(a) {
    for (let b = [!1, 'ms', 'Webkit', 'Moz', 'O'], c = a.charAt(0).toUpperCase() + a.slice(1), d = 0; d < b.length; d++) {
      const e = b[d]; const f = e ? String(e) + c : a; if (typeof document.body.style[f] !== 'undefined') {
        return f
      }
    } return null
  } function G(a) {
    return a && {}.toString.call(a) === '[object Function]'
  } function H(a, b) {
    return a.some((a) => {
      const c = a.name; const d = a.enabled; return d && c === b
    })
  } function I(a, b, c) {
    const d = y(a, (a) => {
      const c = a.name; return c === b
    }); const e = Boolean(d) && a.some((a) => a.name === c && a.enabled && a.order < d.order); if (!e) {
      const f = `\`${b}\``; console.warn(`\`${c}\`` + ` modifier is required by ${f} modifier in order to work, be sure to include it before ${f}!`)
    } return e
  } function J(a) {
    return a !== '' && !isNaN(parseFloat(a)) && isFinite(a)
  } function K(a) {
    const b = a.ownerDocument; return b ? b.defaultView : window
  } function L(a, b) {
    return K(a).removeEventListener('resize', b.updateBound), b.scrollParents.forEach((a) => {
      a.removeEventListener('scroll', b.updateBound)
    }), b.updateBound = null, b.scrollParents = [], b.scrollElement = null, b.eventsEnabled = !1, b
  } function M(a, b, c) {
    const d = void 0 === c ? a : a.slice(0, z(a, 'name', c)); return d.forEach((a) => {
      a.function && console.warn('`modifier.function` is deprecated, use `modifier.fn`!'); const c = a.function || a.fn; a.enabled && G(c) && (b.offsets.popper = p(b.offsets.popper), b.offsets.reference = p(b.offsets.reference), b = c(b, a))
    }), b
  } function N(a, b) {
    Object.keys(b).forEach((c) => {
      const d = b[c]; !1 === d ? a.removeAttribute(c) : a.setAttribute(c, b[c])
    })
  } function O(a, b) {
    Object.keys(b).forEach((c) => {
      let d = ''; ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(c) !== -1 && J(b[c]) && (d = 'px'), a.style[c] = b[c] + d
    })
  } function P(a, b, c, e) {
    const f = a.nodeName === 'BODY'; const g = f ? a.ownerDocument.defaultView : a; g.addEventListener(b, c, {
      passive:!0
    }), f || P(d(g.parentNode), b, c, e), e.push(g)
  } function Q(a, b, c, e) {
    c.updateBound = e, K(a).addEventListener('resize', c.updateBound, {
      passive:!0
    }); const f = d(a); return P(f, 'scroll', c.updateBound, c.scrollParents), c.scrollElement = f, c.eventsEnabled = !0, c
  } var R = Math.max; const S = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined'; var T = S && Boolean(window.MSInputMethodContext && document.documentMode); var U = S && /MSIE 10/.test(navigator.userAgent); var V = Object.assign || function (a) {
    for (var b, c = 1; c < arguments.length; c++) {
      for (const d in b = arguments[c], b) {
        Object.prototype.hasOwnProperty.call(b, d) && (a[d] = b[d])
      }
    } return a
  }; const W = (function () {
    for (let a = ['Edge', 'Trident', 'Firefox'], b = 0; b < a.length; b += 1) {
      if (S && navigator.userAgent.indexOf(a[b]) >= 0) {
        return 1 
} 
} return 0
  }()); const X = S && window.Promise; const Y = X ? function (a) {
    let b = !1; return function () {
      b || (b = !0, window.Promise.resolve().then(() => {
        b = !1, a()
      }))
    }
  } : function (a) {
    let b = !1; return function () {
      b || (b = !0, setTimeout(() => {
        b = !1, a()
      }, W))
    }
  }; a.computeAutoPlacement = x, a.debounce = Y, a.findIndex = z, a.getBordersSize = m, a.getBoundaries = v, a.getBoundingClientRect = q, a.getClientRect = p, a.getOffsetParent = g, a.getOffsetRect = A, a.getOffsetRectRelativeToArbitraryNode = r, a.getOuterSizes = B, a.getParentNode = c, a.getPopperOffsets = D, a.getReferenceOffsets = E, a.getScroll = k, a.getScrollParent = d, a.getStyleComputedProperty = b, a.getSupportedPropertyName = F, a.getWindowSizes = o, a.isFixed = t, a.isFunction = G, a.isModifierEnabled = H, a.isModifierRequired = I, a.isNumeric = J, a.removeEventListeners = L, a.runModifiers = M, a.setAttributes = N, a.setStyles = O, a.setupEventListeners = Q, a.default = {
    computeAutoPlacement:x,
    debounce:Y,
    findIndex:z,
    getBordersSize:m,
    getBoundaries:v,
    getBoundingClientRect:q,
    getClientRect:p,
    getOffsetParent:g,
    getOffsetRect:A,
    getOffsetRectRelativeToArbitraryNode:r,
    getOuterSizes:B,
    getParentNode:c,
    getPopperOffsets:D,
    getReferenceOffsets:E,
    getScroll:k,
    getScrollParent:d,
    getStyleComputedProperty:b,
    getSupportedPropertyName:F,
    getWindowSizes:o,
    isFixed:t,
    isFunction:G,
    isModifierEnabled:H,
    isModifierRequired:I,
    isNumeric:J,
    removeEventListeners:L,
    runModifiers:M,
    setAttributes:N,
    setStyles:O,
    setupEventListeners:Q
  }, Object.defineProperty(a, '__esModule', {
    value:!0
  })
}))
// # sourceMappingURL=popper-utils.min.js.map
